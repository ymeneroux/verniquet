//Comp3D visualization
//Copyright 2013-2021 IGN-Travaux Sp√©ciaux jean-michael.muller@ign.fr paul.bouquet@ign.fr

var translation_en={
  "Oui": "Yes",
  "Non": "No",
  "Code": "Code",
  "Afficher les messages lors de la lecture des fichiers": "Show file reading messages",
  "Masquer les messages lors de la lecture des fichiers": "Hide file reading messages",
  "Afficher les messages lors du param√©trage du calcul": "Show computation configuration messages",
  "Masquer les messages lors du param√©trage du calcul": "Hide computation configuration messages",
  "Afficher les messages lors de la lecture de la configuration": "Show configuration file reading messages",
  "Masquer les messages lors de la lecture de la configuration": "Hide configuration file reading messages",
  "Afficher les messages lors du calcul": "Show computation messages",
  "Masquer les messages lors du calcul": "Hide computation messages",
  "&sigma;X init": "&sigma;X init",
  "&sigma;Y init": "&sigma;Y init",
  "&sigma;Z init": "&sigma;Z init",
  "D√©viation de la verticale ouest-est en secondes d'arc": "Vertical deviation west-east in arc seconds",
  "D√©viation de la verticale sud-nord en secondes d'arc": "Vertical deviation south-north in arc seconds",
  "Type d&apos;observation": "Observation type",
  "Provenance de la mesure": "Mesure provenance",
  "De": "From",
  "Point vis√©": "Targeted point",
  "Vers": "To",
  "Mesure": "Measure",
  "Observation": "Observation",
  "Distance entre les coordonn√©es compens√©es des 2 points": "Distance between adjusted coordinates of the two points",
  "&sigma; absolu + &sigma; relatif": "Absolute &sigma; + relative &sigma;",
  "R√©sidu divis√© par le &sigma; total": "Residual divided by total &sigma;",
  "R√©sidu dans l&apos;unit√© de la mesure": "Residual in the measure unit",
  "√âcart entre l&apos;observation compens√©e et l&apos;observation mesur√©e": "Difference between adjusted and measured obervations",
  "&sigma; sur l&apos;observation obtenue apr√®s compensation": "Observation &sigma; after adjusted",
  "R√©sidu divis√© par le &sigma; a posteriori": "Residual divided by a posteriori &sigma;",
  "0% : observation indispensable / 100% : observation inutile": "0%: essential observation / 100%: unnecessary observation",
  "R√©sidu normalis√© :    *  >3    /    ***  >6    ": "Normalized residual:    * >3    /    ***   >6    ",
  "Cliquer pour d√©plier": "Click to unfold",
  "Version : ": "Version: ",
  "Commit : ": "Commit: ",
  "Options : ": "Options: ",
  "Configuration du chantier": "Project configuration",
  "Nom": "Name",
  " :": ":",
  "Description": "Description",
  "Fichier COR racine": "Root COR file",
  "Fichier de coordonn√©es principal": "",
  "Fichier OBS racine": "Root OBS file",
  "Fichier d&apos;observation principal": "Main observation file",
  "Unit√©": "Unit",
  "Nombre de d√©cimales": "Decimal places number",
  "c&apos;est un indice de la pr√©cision donn√©e dans le rapport, certaines valeurs seront donn√©es avec plus ou moins de d√©cimales": "clue for the precision given in the report, some value are given with less or more decimal places",
  "Type de calcul": "Computation nature",
  "Inversion de la matrice normale": "Normal matrix inversion",
  "N√©cessaire pour obtenir des intervalles et ellipso√Ødes de confiance et obtenir les informations de redondance": "Required to get confidence intervalls and ellipsoids and get redondancy informations",
  "Contraintes internes": "Internal constraints",
  "Coefficient de r√©fraction": "Refraction coefficient",
  "N&apos;affecte que les mesures z√©nithales": "Just impact vertical angle measures",
  "Module lin√©aire": "Point scale",
  "Module lin√©aire moyen du chantier": "Project mean local scale",
  "Geor√©f√©rencement": "Georeferencing",
  "Utilisation d&apos;une projection standard": "Standard projection using",
  "D√©finition projection": "Projection definition",
  "D√©finition proj4 de la projection": "proj4 projection definition",
  "Centre de la projection": "Projection center",
  "Latitude centrale": "Center latitude",
  "Latitude permettant de d√©terminer la courbure locale de l&apos;ellipso√Øde": "Latitude to determine the local curvature of the ellipsoid",
  "Centre des coordonn√©es locales": "Local coordinates center",
  "Crit√®re de convergence": "Convergence criterion",
  "Diff√©rence de œÉ0 entre 2 it√©rations": "œÉ0 difference between 2 iterations",
  "It√©rations maximum": "Maximum iterations",
  "En hauteurs ellipso√Ødales": "Ellipsoidal heights",
  "It√©rations suppl√©mentaires": "Additional iterations",
  "Nombre d&apos;it√©rations suppl√©mentaires apr√®s convergence": "Additional iteration number after convergence",
  "Initialisation avec CAP": "Initialization with CAP",
  "Calcul des coordonn√©es initiales des points non renseign√©s dans le fichier cor": "Initial coordinates computation of points not indicated in the cor file",
  "Informations sur le calcul": "Computation information",
  "Compensation effectu√©e": "Compensation done",
  "Points non initialisables": "Non-initialisable points",
  "&sigma;0 initial": "Initial &sigma;0",
  "&sigma;0 final": "Final &sigma;0",
  "It√©rations": "Iterations",
  "Interruption du calcul": "Computation interruption",
  "D√©faut de rang": "Rank default",
  "D√©but du calcul": "Computation start",
  "Dur√©e du calcul": "Computation duration",
  "Rayon de la sph√®re": "Sphere radius",
  "Nombre d'observations total": "Total observations number",
  "Nombre d'observations actives": "Active observations number",
  "Param√®tres": "Parameters",
  "Avec d√©viation de la verticale": "Using vertical deflection",
  "Nom projection": "Projection name",
  "Cart√©siennes globales vers g√©ocentriques :": "Cartesian Global to Geocentric:",
  "√âvolution du &sigma;0": "&sigma;0 evolution",
  "Iteration": "Iteration",
  "Test du &chi;¬≤": "&chi;¬≤ test",
  "Confiance : ": "Confidence: ",
  "Degr√©s de libert√© : ": "Degrees of freedom: ",
  "Test : ": "Test: ",
  "Test r√©ussi : ": "Test passed: ",
  "Coordonn√©es initiales": "Initial coordinates",
  "He": "Eh",
  "Alti": "Gh",
  "Obs actives": "Active obs",
  "Nombre d&apos;observations actives en lien avec le point": "Active observations number linked to the point",
  "Cliquer pour plier": "Click to fold",
  "Observations": "Observations",
  "R√©partition des r√©sidus": "Residual repartition",
  "Standard": "Standard",
  "Tous les r√©sidus": "All residuals",
  "R√©partition des r√©sidus normalis√©s": "Normalized residuals repartition",
  "Horizontales": "Horizontal",
  "Z√©nithales": "Zenithal",
  "Distances": "Distances",
  "Bascules": "Similarities",
  "Axes": "Axes",
  "Coord": "Coord",
  "D√©nivel√©es": "Direct levelling",
  "R√©partition des r√©sidus normalis√©s par type": "Type-based normalized residuals repartition",
  "R√©sidus absolus moyens par rapport √† la distance": "Average distance-relative normalized absolute residuals repartition",
  "Propositions pseudo al√©atoires": "Pseudo random propositions",
  "Redondance totale du syst√®me : ": "System redundancy: ",
  "Somme des redondances partielles correspondant au degr√© de libert√© du syst√®me": "Sum of partial redundancies corresponding to the degree of freedom of the system",
  "Il faudrait mutiplier les sigmas des observations par :": "Observations sigmas may be multiplied by:",
  "Pas assez d'observations": "Not enough observations",
  "Pas assez de redondance": "Not enough redundancy",
  "La moyenne des redondances partielles de ce type est inf√©rieure √† 30%": "The partial redundancies average of this type is less than 30%",
  "Nombre d'observations de ce type : ": "Observation number of this type: ",
  " dont ": " including ",
  " redondantes": " redundant ",
  "Somme des redondances partielles de ce type : ": "Sum of partial redundancies of this type: ",
  "soit": "which correponds to",
  "de la redondance totale": "of the total redundancy",
  "Moyenne des redondances partielles de ce type : ": "Partial redundancies average of this type: ",
  "Plus gros r√©sidus": "Biggest residuals",
  "les 20 plus gros r√©sidus normalis√©s du plus grand au plus petit": "20 biggest normalized residuals",
  "les 20 plus gros r√©sidus norm√©s du plus grand au plus petit": "20 biggest standardized residuals",
  "Nom fichier": "File name",
  "Point origine": "Origin point",
  "Verticale": "Vertical",
  "Coordonn√©es cart√©siennes globales": "Global cartesian coordinates",
  "D√©viation": "Deviation",
  "Axe ": "Axis ",
  " sur point ": " on point ",
  "Param√©trage de l'axe": "Axis parametrization",
  "ID cible ": "Target ID",
  "Abscisse": "Abscissa",
  "Rayon": "Radius",
  "Positions": "Positions",
  "Coordonn√©es compens√©es": "Compensated coordinates",
  "Ellipso√Ødes de confiance": "Confidence ellipsoids",
  "1/2 Axe (mm)": "1/2 Axis (mm)",
  "Gisement (gr)": "Bearing (gr)",
  "Site (gr)": "Tilt (gr)",
  "Demi-intervalles de confiance": "Confidence semi-intervals",
  "Demi-intervalles de confiance 1D √† 1 ùúé (68%)": "1D 1 ùúé confidence semi-intervals (68%)",
  "&sigma;X (mm)": "&sigma;X (mm)",
  "&sigma;Y (mm)": "&sigma;Y (mm)",
  "&sigma;Z (mm)": "&sigma;Z (mm)",
  "Simulation des d√©placements des points": "Points displacements simulation",
  "Pour ": "For ",
  " simulations :": " simulations:",
  "EMQ X (mm)": "MSE X (mm)",
  "EMQ Y (mm)": "MSE Y (mm)",
  "EMQ Z (mm)": "MSE Z (mm)",
  "Max X (mm)": "Max X (mm)",
  "Max Y (mm)": "Max Y (mm)",
  "Max Z (mm)": "Max Z (mm)",
  "Distance": "Distance",
  "&sigma; total": "Total &sigma;",
  "R√©sidu normalis√©": "Normalized residual",
  "R√©sidu": "Residual",
  "R√©sidu mm": "Residual mm",
  "&sigma; a posteriori": "A posteriori &sigma;",
  "R√©sidu standard": "Standard residual",
  "Redondance": "Redondancy",
  "Gros r√©sidu": "Big residual",
  "Angles horizontaux": "Horizontal angles",
  "Angles z√©nithaux": "Zenith angles",
  "Coordonn√©es": "Coordinates",
  "Radians": "Rad",
  "Grades": "Grad",
  "Degr√©s": "Deg",
  "DMS": "DMS",
  "Compensation": "Compensation",
  "Simulation propagation": "Simulation propagation",
  "Simulation Monte-Carlo": "Simulation Monte-Carlo",
  "Ref": "Ref",
  "Station": "Station",
  "Cible": "Target",
  " - Comp3D": " - Comp3D",
}

//------------------------------------------------------------------------------
// begin simple_i18n functions
//------------------------------------------------------------------------------
var translations = {
  // update list of translations here, example: "fr":translation_fr,
  "en": translation_en,
};
//choose the translation here
var current_dict = {};
function _(key) {
  if (key in current_dict)
    return current_dict[key]
  return key;
}
// end simple_i18n functions

//------------------------------------------------------------------------------
// D√©clarations des variables
//------------------------------------------------------------------------------
const codes_obs = {
  "-1": "coord_x",
  "-2": "coord_y",
  "-3": "coord_z",
  "1": "dist",
  "2": "dist hz",
  "3": "dist",
  "4": "den",
  "5": "hz",
  "6": "zen",
  "7": "tour",
  "8": "azim",
  "9": "center_meta",
  "10": "photo",
  "11": "scanner",
  "12": "tracker",
  "13": "align",
  "14": "dE",
  "15": "dN",
  "18": "axis",
  "91": "center_x",
  "92": "center_y",
  "101": "bascule_x",
  "102": "bascule_y",
  "103": "bascule_z",
  "104": "bascule_hz",
  "105": "bascule_zen",
  "106": "bascule_dist",

  "181": "axe_r",
  "182": "axe_l",
  "184": "axe_c",
  "187": "axe_fx",
  "188": "axe_fy",
  "189": "axe_fz",

  "201": "cint_tx",
  "202": "cint_ty",
  "203": "cint_tz",
  "204": "cint_rx",
  "205": "cint_ry",
  "206": "cint_rz",
  "207": "cint_sc",
};
const codes_pt = {
  0: "---",
  1: "XYZ",
  2: "XY-",
  3: "--Z",
  4: "-&nbsp;&nbsp;",
  5: "&nbsp;&nbsp;Z",
  6: "--&nbsp;",
  7: "XY&nbsp;",
  8: "f--",
  9: "fXY",
  undefined: "",
};
const type_obs = {
  1 : "dist",
  2 : "dist",
  3 : "dist",
  4 : "den",
  5 : "hz",
  7 : "hz",
  8 : "hz",
  6 : "zen",
  101 : "basc",
  102 : "basc",
  103 : "basc",
  104 : "basc",
  105 : "basc",
  106 : "basc",
  181 : "axis",
  182 : "axis",
  183 : "axis",
  184 : "axis",
  185 : "axis",
  186 : "axis",
  187 : "axis",
  188 : "axis",
  189 : "axis",
  "-1" : "coord",
  "-2" : "coord",
  "-3" : "coord",
};

const parite = ["paire", ""];
const max_biggest_residuals = 20;
//Step for residual ananlysis
const first_step_standardized_residual=2.5
const second_step_standardized_residual=4.1
const first_step_normalized_residual=3
const second_step_normalized_residual=6
var num_decimales;
var num_decimales_mini;
var items;
var all_pts = [];
var nb_pts;
var all_pts_name = {};
var all_files = [];
var all_obs = [];
var all_basc = [];
var all_axes = [];
var all_active_obs = [];
var nb_obs_active;
//variables to know if obs type exist for graph
var exist = {};
exist["hz"] = false;
exist["zen"] = false;
exist["dist"] = false;
exist["basc"] = false;
exist["axis"] = false;
exist["coord"] = false;
exist["den"] = false;

//global for map
let mymap;
let minx;
let miny;
let maxx;
let maxy; 

//variables listing atrributes of column being able to fold (using in get_head_obs and obs2tab)
const id_fold=["obs_length","sigma_total","normalized_residual","residual","residual_mm","sigma_a_posteriori","residualStd","standardized_residual","obsRedondancy","nabla","probableError"];
function need_inversion(id_fold){
  if ((id_fold=="sigma_a_posteriori") ||(id_fold=="residualStd")||(id_fold=="standardized_residual")||(id_fold=="obsRedondancy")||(id_fold=="nabla")||(id_fold=="probableError")) return "class_need_inversion";
  else return ""
};

//------------------------------------------------------------------------------
// Fonctions used in the different parts
//------------------------------------------------------------------------------

function bool(result){
    if (result) return _("Oui");
    else return _("Non");
}

function add_post(str){
    return '<span post="&nbsp;'+str+'&nbsp;"></span>';
}

function add_circle_comment(pt){
  if (!pt) return "";
  else if ((pt.comment=="")||(pt.comment=="*")) return "";
  else return '<span post="&nbsp;&#9432;"></span>';
}

function add_comment(pt,nv_tool_tip){
  if (!pt) return "";
  else if ((pt.comment=="")||(pt.comment=="*")) return "";
  else{
    if (nv_tool_tip)
    {
      return '<span class="tooltip"><span class="comment">' + pt.comment + '</span></span>';
    }else{
      return '<span class="comment">' + pt.comment + '</span>';
    }
  }
}

function add_name(pt,i,rowspan){
  return '<tr class=\"' + parite[i % 2] + '\"><td class=\"name\" rowspan="' + rowspan + '">' + add_post(codes_pt[pt.code]) + pt.name + add_circle_comment(pt) + add_comment(pt,1) + '</td>';
}

function add_code_obs(obs,file2tooltip){
  return '<td class=\"code\" >' +  codes_obs[obs.code] + add_circle_comment(obs) +'<span class="tooltip">'+_("Code") + file2tooltip + '</br>' + add_comment(obs) + '</span>' +  '</td>'
}

function displayMessagesRead() {
  if (document.getElementById("messages_read_data").style.display == "block")
  {
    document.getElementById('messages_read_data').style.display = 'none';
    document.getElementById('messageRead').style.fontWeight = 'normal';
    document.getElementById("messageRead").value = _("Afficher les messages lors de la lecture des fichiers");
  }
  else
  {
    document.getElementById('messages_read_data').style.display = 'block';
    document.getElementById('messageRead').style.fontWeight = 'bold';
    document.getElementById("messageRead").value = _("Masquer les messages lors de la lecture des fichiers");
  }
}

function displayMessagesLeast_squares() {
  if (document.getElementById("messages_set_least_squares").style.display == "block")
  {
    document.getElementById('messages_set_least_squares').style.display = 'none';
    document.getElementById('messageLeast').style.fontWeight = 'normal';
    document.getElementById("messageLeast").value = _("Afficher les messages lors du param√©trage du calcul");
  }
  else
  {
    document.getElementById('messages_set_least_squares').style.display = 'block';
    document.getElementById('messageLeast').style.fontWeight = 'bold';
    document.getElementById("messageLeast").value = _("Masquer les messages lors du param√©trage du calcul");
  }
}

function displayMessagesReadConfig() {
  if (document.getElementById("messages_read_config").style.display == "block")
  {
    document.getElementById('messages_read_config').style.display = 'none';
    document.getElementById('messageReadC').style.fontWeight = 'normal';
    document.getElementById("messageReadC").value = _("Afficher les messages lors de la lecture de la configuration");
  }
  else
  {
    document.getElementById('messages_read_config').style.display = 'block';
    document.getElementById("messageReadC").value = _("Masquer les messages lors de la lecture de la configuration");
    document.getElementById('messageReadC').style.fontWeight = 'bold';
  }
}

function displayMessagesComputation() {
  if (document.getElementById("messages_computation").style.display == "block")
  {
    document.getElementById('messages_computation').style.display = 'none';
    document.getElementById('messageComputation').style.fontWeight = 'normal';
    document.getElementById("messageComputation").value = _("Afficher les messages lors du calcul");
  }
  else
  {
    document.getElementById('messages_computation').style.display = 'block';
    document.getElementById('messageComputation').style.fontWeight = 'bold';
    document.getElementById("messageComputation").value = _("Masquer les messages lors du calcul");
  }
}

function pointSortFunction(p1, p2) {//make points and obs lists
  if (p1.number > p2.number)
    return 1
  else if (p1.number < p2.number)
    return -1
  else return 0;
}

function obsSortFunction(o1, o2) {
  if (o1.number > o2.number)
    return 1
  else if (o1.number < o2.number)
    return -1
  else return 0;
}

function residualSortFunction(o1, o2) {
  if (data["computation"]["invertedMatrix"]){//standardized_residual has been computed
    if ((o1.standardized_residual)&&(o2.standardized_residual)){//standardized_residual of the 2 obs exist
      if (Math.abs(o1.standardized_residual) < Math.abs(o2.standardized_residual))
        return 1
      else if (Math.abs(o1.standardized_residual) > Math.abs(o2.standardized_residual))
        return -1
    }else if (o1.standardized_residual){//o1 standardized_residual exist but not o2
      return -1
    }else if (o2.standardized_residual){//o2 standardized_residual exist but not o1
      return 1
    }else{//o1 and o2 standardized_residual not exist
      return 0;
    }
  }else{
    if (Math.abs(o1.normalized_residual) < Math.abs(o2.normalized_residual))
      return 1
    else if (Math.abs(o1.normalized_residual) > Math.abs(o2.normalized_residual))
      return -1
    else return 0;
  }
}

function residual_is_big(obs){
  if (data["computation"]["invertedMatrix"] && (Math.abs(obs.standardized_residual)>first_step_standardized_residual))
    return true;
  else if (!data["computation"]["invertedMatrix"] && (Math.abs(obs.normalized_residual)>first_step_normalized_residual))
    return true;
  else
    return false;
}

function point_sigmas(pt) {
   //affiche les sigmas des points en fonction de leur type (3D ou 1D libre ou fix√©) et g√®re la mise en forme en fonction de leur signe
    if (pt.code === 1)
     return ('<td class="'+((parseFloat(pt.sigmas_init[0])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[0]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;X init") + '</span>' +
            '</td><td class="'+((parseFloat(pt.sigmas_init[1])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[1]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;Y init") + '</span>' +
            '</td><td class="'+((parseFloat(pt.sigmas_init[2])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[2]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;Z init") + '</span></td>');
    else if (pt.code === 2)
     return ('<td class="'+((parseFloat(pt.sigmas_init[0])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[0]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;X init") + '</span>' +
        '</td><td class="'+((parseFloat(pt.sigmas_init[1])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[1]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;Y init") + '</span>' +
        '</td><td>' + '</td>');
    else if (pt.code === 3)
      return ('<td>' +
        '</td><td>' +
        '</td><td class="'+((parseFloat(pt.sigmas_init[2])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[2]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;Z init") + '</span></td>');
    else if (pt.code === 4)
      return ('<td>-' +
        '</td><td>-' +
        '</td><td></td>');
    else if (pt.code === 5)
      return ('<td>-' +
        '</td><td>-' +
        '</td><td class="'+((parseFloat(pt.sigmas_init[2])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[2]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;Z init") + '</span></td>');
    else if (pt.code === 6 || pt.code === 8)
      return ('<td>' +
        '</td><td>' +
        '</td><td>-</td>');
    else if (pt.code === 7 || pt.code === 9)
        return ('<td class="'+((parseFloat(pt.sigmas_init[0])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[0]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;X init") + '</span>' +
           '</td><td class="'+((parseFloat(pt.sigmas_init[1])<0)?"inactive":"")+'">' + parseFloat(pt.sigmas_init[1]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+_("&sigma;Y init") + '</span>' +
           '</td><td>-</td>');
    else return ('<td></td><td></td><td></td>');
}

function get_head_dev() {
  if (data["computation"]["use_vertical_deviation"]){
    return ("<th class='small' title='"+_("D√©viation de la verticale ouest-est en secondes d'arc")+"'>" + "&#951;" + "</th>"+
            "<th class='small' title='"+_("D√©viation de la verticale sud-nord en secondes d'arc")+"'>" + "&#958;" + "</th>");
  }
}

function get_dev(pt) {
  if (data["computation"]["use_vertical_deviation"]){
    return('<td class="small" >' + parseFloat((pt.dev_eta*(3600*180)/Math.PI).toFixed(num_decimales)) + '<span class="tooltip">'+_("D√©viation de la verticale ouest-est en secondes d'arc") + '</span></td>'+
           '<td class="small" >' + parseFloat((pt.dev_xi*(3600*180)/Math.PI).toFixed(num_decimales)) + '<span class="tooltip">'+_("D√©viation de la verticale sud-nord en secondes d'arc") + '</span></td>');
  }
}

function get_head_obs(items) {
  items.push(
    "<th title='"+_('Type d&apos;observation') +"' class=\"name\">" + _("Code") +
    "</th><th title='"+_("Provenance de la mesure") +"' class=\"name\">" + _("De") +
    "</th><th title='"+_("Point vis√©") +"' class=\"name\">" + _("Vers") +
    "</th><th title='"+_('Observation')+"'>" + _("Mesure"));

  const help_fold = {
    "obs_length": _("Distance entre les coordonn√©es compens√©es des 2 points"),
    "sigma_total": _("&sigma; absolu + &sigma; relatif"),
    "normalized_residual" :  _("R√©sidu divis√© par le &sigma; total"),
    "residual" : _("R√©sidu dans l&apos;unit√© de la mesure"),
    "residual_mm" : _("√âcart entre l&apos;observation compens√©e et l&apos;observation mesur√©e"),
    "sigma_a_posteriori" : _("&sigma; sur l&apos;observation obtenue apr√®s compensation"),
    "residualStd" : _("R√©sidu divis√© par le &sigma; a posteriori"),
    "standardized_residual" : _("R√©sidu divis√© par sa pr√©cision"),
    "obsRedondancy" : _("0% : observation indispensable / 100% : observation inutile"),
    "nabla": _("Fiabilit√© interne : valeur de la plus grande faute non d√©tectable"),
    "probableError" : _("Valeur de la faute probable \n Affich√©e si r√©sidu norm√© > 2.5")
  };
  for (var id of id_fold) {
    items.push("</th><th class='small "+need_inversion(id)+" "+id+" hand' title='"+_(help_fold[id]) + "' onclick='toggle(\""+id+"\")'>" +_(title_fold[id]) +
      "</th><th class='mask mask_"+id+" hand' title='"+_(title_fold[id]) +" -> "+_("Cliquer pour d√©plier") + "' onclick='toggle(\""+id+"\")'>&#x27A4;&#x27A4;");
  }
  items.push("</th></tr></thead>");
  return items;
}

function toggle(column){
  name_cookie="style_" + column;
  mask_column='mask_' + column;
  if (getCookie(name_cookie)){
    if (getCookie(name_cookie)=="table-cell"){
      new_style="none";
      $('.'+column).hide();
      $('.'+mask_column).show();
    }else{
      new_style="table-cell";
      $('.'+column).show();
      $('.'+mask_column).hide();
    }
  }else{
    new_style="none";
    $('.'+column).hide();
    $('.'+mask_column).show();
  }
  setCookie(name_cookie,new_style);
}

function set_display_column(){
  var mask_column;var cookie;
  for (var column of id_fold) {
    if ($('#column')){
      mask_column='.mask_'+column;
      cookie=getCookie('style_'+column)
      if (cookie){
        if (cookie=='none'){
          $('.'+column).hide();
          $(mask_column).show();
        }else{
          $('.'+column).show();
          $(mask_column).hide();
        }
      }else{
        $(mask_column).hide();
      }
    }
  }
}

function setCookie(cname, cvalue) {
  document.cookie = cname + "=" + cvalue;
}

function getCookie(cname) {
  var name = cname + "=";
  var decodedCookie = decodeURIComponent(document.cookie);
  var ca = decodedCookie.split(';');
  for(var i = 0; i <ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

//------------------------------------------------------------------------------
// Fonctions d'affichage des parties et de l'entr√©e associ√©e dans le sommaire
//------------------------------------------------------------------------------

function show_version(){
  //Version de Comp3D ------------------------------------------------------------------------------------
  $("<p/>", {
    text: _('Version : ') + data["COMP3D_VERSION"],
    id: 'version'
  }).appendTo('body');
  $("<p/>", {
    text: _('Commit : ') + data["COMP3D_COMMIT"],
    id: 'commit'
  }).appendTo('body');
  $("<p/>", {
    text: _('Options : ') + data["COMP3D_OPTIONS"],
    id: 'options'
  }).appendTo('body');
  $("<p/>", {
    text: data["COMP3D_COPYRIGHT"]+ ' - ' + data["COMP3D_LICENSE"],
    id: 'License'
  }).appendTo('body');
}

function show_info_work(){
  //Configuration du chantier ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#info_work">' + _('Configuration du chantier') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Configuration du chantier'),
    id: 'info_work'
  }).appendTo('#rapport');
  items=[];

  items.push("<dt>" + _("Nom") + _(" :") + "</dt>");
  if (data["config"]["name"]===""){
    items.push("<dd>-</dd>");
  }else{
    items.push("<dd>" + data["config"]["name"] + "</dd>");
  }
  items.push("<dt>" + _("Description") + _(" :") + "</dt>");
  if (data["config"]["description"]===""){
    items.push("<dd>-</dd>");
  }else{
    items.push("<dd>" + data["config"]["description"] + "</dd>");
  }
  items.push("<dt title='"+_('Fichier de coordonn√©es principal')+"'>" + _("Fichier COR racine") + _(" :") + "</dt><dd>" + data["config"]["root_COR_file"] + '</dd>');
  items.push("<dt title='"+_('Fichier d&apos;observation principal')+"'>" + _("Fichier OBS racine") + _(" :") + "</dt><dd>" + data["config"]["root_OBS_file"] + '</dd>');
  items.push("<dt>" + _("Unit√©") + _(" :") + "</dt><dd>" + unit[data["config"]["files_unit"]] + '</dd>');
  items.push("<dt title='"+_('c&apos;est un indice de la pr√©cision donn√©e dans le rapport, certaines valeurs seront donn√©es avec plus ou moins de d√©cimales')+"'>" + _("Nombre de d√©cimales") + _(" :") + "</dt><dd>" + parseInt(data["config"]["nb_digits"]) + '</dd>');
  items.push("<dt>" + _("Type de calcul") + _(" :") + "</dt><dd>" + type_calcul[data["config"]["compute_type"]] + '</dd>');
  if (data["config"]["compute_type"] == 0)
      items.push("<dt title='"+_('N√©cessaire pour obtenir des intervalles et ellipso√Ødes de confiance et obtenir les informations de redondance')+"'>" + _("Inversion de la matrice normale") + _(" :") + "</dt><dd>" + bool(data["config"]["invert_matrix"]) + '</dd>');
  if (data["config"]["compute_type"] != 2)
      items.push("<dt>" + _("Contraintes internes") + _(" :") + "</dt><dd>" + bool(data["config"]["internal_constraints"]) + '</dd>');
  items.push("<dt title='"+_('N&apos;affecte que les mesures z√©nithales')+"'>" + _("Coefficient de r√©fraction") + _(" :") + "</dt><dd>" + parseFloat(data["config"]["refraction"]).toFixed(num_decimales) + '</dd>');
  //items.push("<dt title='"+_('Module lin√©aire moyen du chantier')+"'>" + _("Module lin√©aire") + _(" :") + "</dt><dd>" + parseFloat(data["config"]["local_scale"]).toFixed(6) + '</dd>');
  items.push("<dt title='"+_('Utilisation d&apos;une projection standard')+"'>" + _("Geor√©f√©rencement") + _(" :") + "</dt><dd>" + bool(data["config"]["use_proj"]) + '</dd>');

  if (data["config"]["use_proj"])
  {
      items.push("<dt title='"+_('D√©finition proj4 de la projection')+"'>" + _("D√©finition projection") + _(" :") + "</dt><dd>" + data["config"]["proj_def"] + '</dd>');
      items.push("<dt>" + _("Centre de la projection") + _(" :") + "</dt><dd>" +
        "E=" + parseFloat(data["config"]["local_center"][0]).toFixed(0) + " " +
        "N=" + parseFloat(data["config"]["local_center"][1]).toFixed(0) + '</dd>');
  }else{
      items.push("<dt title='"+_('Latitude permettant de d√©terminer la courbure locale de l&apos;ellipso√Øde')+"'>" + _("Latitude centrale") + _(" :") + "</dt><dd>" + parseFloat(data["config"]["center_latitude"]).toFixed(2) + '</dd>');
      items.push("<dt>" + _("Centre des coordonn√©es locales") + _(" :") + "</dt><dd>" +
        "X=" + parseFloat(data["config"]["local_center"][0]).toFixed(0) + " " +
        "Y=" + parseFloat(data["config"]["local_center"][1]).toFixed(0) + '</dd>');
  }

  items.push("<dt title='"+_('Diff√©rence de œÉ0 entre 2 it√©rations')+"'>" + _("Crit√®re de convergence") + _(" :") + "</dt><dd>" + parseFloat(data["config"]["convergence_criterion"]).toFixed(6) + '</dd>');
  items.push("<dt>" + _("It√©rations maximum") + _(" :") + "</dt><dd>" + parseInt(data["config"]["max_iterations"]) + '</dd>');
  items.push("<dt>" + _("En hauteurs ellipso√Ødales") + _(" :") + "</dt><dd>" + bool(data["config"]["use_ellips_height"]) + '</dd>');
  items.push("<dt title='"+_('Nombre d&apos;it√©rations suppl√©mentaires apr√®s convergence')+"'>" + _("It√©rations suppl√©mentaires") + _(" :") + "</dt><dd>" + parseInt(data["config"]["force_iterations"]) + '</dd>');
  $('<dl/>', {
    'class': 'inline-flex',
    html: items.join('')
  }).appendTo('#rapport');
}

function show_info_calc(){
  //Informations sur le calcul ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#info_calc">' + _('Informations sur le calcul') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Informations sur le calcul'),
    id: 'info_calc'
  }).appendTo('#rapport');
  items = ["<dt>" + _("Compensation effectu√©e") + _(" :") + "</dt><dd>" + bool(data["computation"]["compensationDone"]) + '</dd>'];

  if (data["all_uninitializable_point_names"] && (data["all_uninitializable_point_names"].length>0))
    items.push("<dt>" + _("Points non initialisables") + _(" :") + "</dt><dd>" + data["all_uninitializable_point_names"].join(" ") + '</dd>');

  if (data["config"]["compute_type"] === 0) {
    items.push("<dt>"+ _("&sigma;0 initial") +_(" :") + "</dt><dd>" + parseFloat(data["computation"]["sigma_0_init"]).toFixed(num_decimales) + '</dd>');
    items.push("<dt>" + _("&sigma;0 final") + _(" :") + "</dt><dd>" + parseFloat(data["computation"]["sigma_0_final"]).toFixed(num_decimales) + '</dd>');
  }
  items.push("<dt>" + _("It√©rations") + _(" :") + "</dt><dd>" + parseInt(data["computation"]["nbr_iterations"]) + '</dd>');
  var interrupted_class = "";
  if (data["computation"]["interrupted"])
      interrupted_class = "warn_red";
  items.push("<dt>" + _("Interruption du calcul") + _(" :") + "</dt><dd class='"+interrupted_class+"'>" + bool(data["computation"]["interrupted"]) + '</dd>');
  items.push("<dt>" + _("D√©faut de rang") + _(" :") + "</dt><dd>" + parseInt(data["computation"]["rank_default"]) + '</dd>');
  if (data["computation"]["computation_start"]!=="not-a-date-time"){
     items.push("<dt>" + _("D√©but du calcul") + _(" :") + "</dt><dd>" + data["computation"]["computation_start"] + '</dd>');
     items.push("<dt>" + _("Dur√©e du calcul") + _(" :") + "</dt><dd>" + data["computation"]["computation_duration"] +'</dd>');
  }
  items.push("<dt>" + _("Rayon de la sph√®re") + _(" :") + "</dt><dd>" + parseFloat(data["computation"]["projection"]["earth_model_radius"]).toFixed(2) + ' m</dd>');

  items.push("<dt>" + _("Nombre d'observations total") + _(" :") + "</dt><dd>" + parseInt(data["computation"]["nbr_all_obs"]) + '</dd>');
  items.push("<dt>" + _("Nombre d'observations actives") + _(" :") + "</dt><dd>" + parseInt(data["computation"]["nbr_active_obs"]) + '</dd>');
  items.push("<dt>" + _("Param√®tres") + _(" :") + "</dt><dd>" + parseInt(data["computation"]["nbr_parameters"]) + '</dd>');
  items.push("<dt>" + _("Inversion de la matrice normale") + _(" :") + "</dt><dd>" + bool(data["computation"]["invertedMatrix"]) + '</dd>');
  items.push("<dt>" + _("Contraintes internes") + _(" :") + "</dt><dd>" + bool(data["computation"]["internal_constraints"]) + '</dd>');
  items.push("<dt>" + _("Avec d√©viation de la verticale") + _(" :") + "</dt><dd>" + bool(data["computation"]["use_vertical_deviation"]) + '</dd>');

  if (data["computation"]["projection"]["is_georef"])
  {
      var R=data["computation"]["projection"]["rot_global2geocentric"];
      var T=data["computation"]["projection"]["center_cartgeocentric"];
      if (data["computation"]["projection"]["input_proj_EPSG"]>0)
        items.push("<dt>" + _("Nom projection") + _(" :") + "</dt><dd> EPSG " + data["computation"]["projection"]["input_proj_EPSG"]+": "+data["computation"]["projection"]["input_proj_name"] + '</dd>');

      items.push("<table><th class='likedt' colspan='4'>" + _("Cart√©siennes globales vers g√©ocentriques :") + "</th>"
                 + "<tr><td></td><td>" + R[0][0] + "</td><td>" + R[0][1] + "</td><td>" + R[0][2] + "</td><td></td><td>" + T[0] + "</td></tr>"
                 + "<tr><td>Geocentr =</td><td>" + R[1][0] + "</td><td>" + R[1][1] + "</td><td>" + R[1][2] + '</td><td>* Global + </td><td>' + T[1] + "</td></tr>"
                 + "<tr><td></td><td>" + R[2][0] + "</td><td>" + R[2][1] + "</td><td>" + R[2][2] + "</td><td></td><td>" + T[2] + '</td></tr></table>');
  }

  $('<dl/>', {
    'class': 'inline-flex',
    html: items.join('')
  }).appendTo('#rapport');
  items=['<p><input type="button" id="messageReadC" onclick="displayMessagesReadConfig()" ></input></p> '];
  items.push('<div id="messages_read_config" style="display: none;" >'+ data["computation"]["messages_read_config"]+'</div>');
  items.push('<p><input type="button" id="messageRead" onclick="displayMessagesRead()"></input></p> ');
  items.push('<div id="messages_read_data" style="display: block;" >'+ data["computation"]["messages_read_data"]+'</div>');
  items.push('<p><input type="button" id="messageLeast" onclick="displayMessagesLeast_squares()"></input></p> ');
  items.push('<div id="messages_set_least_squares" style="display: block;" >'+ data["computation"]["messages_set_least_squares"]+'</div>');
  items.push('<p><input type="button" id="messageComputation" onclick="displayMessagesComputation()"></input></p> ');
  items.push('<div id="messages_computation" style="display: none;" >'+ data["computation"]["messages_computation"]+'</div>');
  $('<div/>', {
    html: items.join('')
  }).appendTo('#rapport');

  displayMessagesReadConfig();
  displayMessagesRead();
  displayMessagesLeast_squares();
  displayMessagesComputation();
}

function show_evol_sigma0(){
  //Graph sigma 0 ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#evol_sigma0">' + _('√âvolution du &sigma;0') + '</a>').appendTo('#sommaire');
  var all_sigma0_labels = [];
  var chi2_max = [];
  var chi2_min = [];
  var all_sigma0_val = [];
  $.each(data["computation"]["all_sigma0"], function(index, value) {
    all_sigma0_labels.push(index);
    all_sigma0_val.push(value);
    chi2_max.push(data["computation"]["chi2_test"]["max"]);
    chi2_min.push(data["computation"]["chi2_test"]["min"]);
  });
  var sigma0_evol_chart_config = {
    type: 'line',
    data: {
      labels: all_sigma0_labels,
      datasets: [{
          label: "sigma0",
          backgroundColor: "rgba(255,162,0,0.5)",
          fill: false,
          borderColor: "rgba(255,162,0,1)",
          pointColor: "rgba(255,162,0,1)",
          pointStrokeColor: "#fff",
          data: all_sigma0_val,
          lineTension: 0.0
        },
        {
          label: "chi2 max",
          borderColor: "rgba(150,100,100,0.9)",
          pointRadius: 0,
          data: chi2_max,
          fill: false
        },
        {
          label: "chi2 min",
          borderColor: "rgba(100,150,100,0.9)",
          pointRadius: 0,
          data: chi2_min,
          fill: false
        }
      ]
    },
    options: {
      responsive: true,
      title: {
        display: false,
      },
      tooltips: {
        mode: 'index',
        intersect: false,
      },
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: _('Iteration')
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: 'Sigma0'
          },
          type: 'logarithmic',
          ticks: {
            min: 0,
            callback: function(value, index, values) {
              str = value.toExponential()
              if ((str[0] == "1") || (str[0] == "2") || (str[0] == "5"))
                return value.toString();
              else return "";
            },
          }
        }]
      }
    }
  };
  $("<h2/>", {
    html: _('√âvolution du &sigma;0'),
    id: "evol_sigma0"
  }).appendTo('#rapport');
  $("<div class='graph'><canvas id='sigma0_chart'></canvas></div>").appendTo('#rapport');
  var ctx = $("#sigma0_chart").get(0).getContext("2d");
  //This will get the first returned node in the jQuery collection.
  var myNewChart = new Chart(ctx, sigma0_evol_chart_config);
}

function show_chi2(){
  //Test du chi2 ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#test_chi2">' + _('Test du &chi;¬≤') + '</a>').appendTo('#sommaire');
  var chi2OK = (parseFloat(data["computation"]["chi2_test"]["min"]) < parseFloat(data["computation"]["sigma_0_final"])) &&
    (parseFloat(data["computation"]["sigma_0_final"]) < parseFloat(data["computation"]["chi2_test"]["max"]));
  var emoticon = "?";
  if (!chi2OK) emoticon = "&#128547;";
  else emoticon = "&#128517;";
  if (parseFloat(data["computation"]["sigma_0_final"]) > 10)
    emoticon = "&#128561;";
  else if (parseFloat(data["computation"]["sigma_0_final"]) > 100)
    emoticon = "&#128552;";
  $("<h2/>", {
    html: _('Test du &chi;¬≤') + _(" :") + " " + emoticon,
    id: "test_chi2"
  }).appendTo('#rapport');
  $("<p>", {
    text: _('Confiance : ') + data["computation"]["chi2_test"]["confidence"] * 100 + "%"
  }).appendTo('#rapport');
  $("<p>", {
    text: _('Degr√©s de libert√© : ') + data["computation"]["chi2_test"]["DOF"],
    title: _('Nombre d\'observations actives moins nombre de param√®tres')
  }).appendTo('#rapport');
  $("<p>", {
    text: _('Test : ') + parseFloat(data["computation"]["chi2_test"]["min"]).toFixed(num_decimales) + " < " +
      parseFloat(data["computation"]["sigma_0_final"]).toFixed(num_decimales) + " < " +
      parseFloat(data["computation"]["chi2_test"]["max"]).toFixed(num_decimales) + " ?"
  }).appendTo('#rapport');
  //see http://character-code.com/emoticons-html-codes.php
  $("<p>", {
    html: _('Test r√©ussi : ') + bool(chi2OK) + " !"
  }).appendTo('#rapport');
}

function show_coord_init(){
  //write init coords ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#coord_init">' + _('Coordonn√©es initiales') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Coordonn√©es initiales'),
    id: 'coord_init'
  }).appendTo('#rapport');
  items = ["<tr><th class=\"name\">" + _("Nom")+'</th>'];

  var composant;
  if (data["config"]["use_proj"]){
    composant=["E","N"];
  }else{
    composant=["X","Y"];
  }
  if (data["config"]["use_ellips_height"])
    composant.push(_("He"));
  else
    composant.push(_("Alti"));
  items.push("<th>" + composant[0] + " init" +
    "</th><th>" + composant[1] + " init" +
    "</th><th>" + composant[2] + " init"
  );
  items.push("</th><th>" + _("&sigma;X init") +
    "</th><th>" + _("&sigma;Y init") +
    "</th><th>" + _("&sigma;Z init")
  );
  items.push(get_head_dev());
  items.push("</th><th class='small' title='"+_('Nombre d&apos;observations actives en lien avec le point')+"'>" + _("Obs actives") + "</th><\tr>");
  for (var i = 0; i < nb_pts; i++) {
    var pt = all_pts[i];
    items.push(add_name(pt,i,1));
    items.push('<td>' + parseFloat(pt.coord_read[0]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">' + composant[0] + ' init</span>' +
               '</td><td>' + parseFloat(pt.coord_read[1]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">' + composant[1] + ' init</span>' +
               '</td><td>' + parseFloat(pt.coord_read[2]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">' + composant[2] + ' init</span></td>'
    );
    items.push(point_sigmas(pt));
    items.push(get_dev(pt));
    items.push('<td class="small" >' + pt.nbActiveObs + '<span class="tooltip">'+_('Nombre d&apos;observations actives en lien avec le point') + '</span></td><\tr>');
  }
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport')
}

function obs2tab(obs,i,isbiggest){
  var str_active_class = '';
  var str_gros_residu_class ='';
  var value_sigma_a_posteriori='';				//Sigma a posteriori
  var value_residualStd='';				//R√©sidu standard
  var value_standardized_residual='';	//R√©sidu norm√©
  var value_obsRedondancy='';
  var value_nabla='';
  var value_probableError='';
  if (!obs.active){
    value_sigma_a_posteriori="-";
    value_residualStd="-"
    value_obsRedondancy="-";
    value_standardized_residual='-';
    value_nabla="-";
    value_probableError="-";
    str_active_class = ' inactive';
  }else{
    value_sigma_a_posteriori=parseFloat(obs.sigma_a_posteriori).toFixed(num_decimales)+ add_post(obs.unit_str);
    value_residualStd=parseFloat(obs.residualStd).toFixed(num_decimales_mini)+ add_post("ùúé");
    value_obsRedondancy=Math.abs(parseFloat(obs.obsRedondancy)).toFixed(0) + add_post("%");
    if (obs.nabla){//si le nabla existe, standardized_residual aussi => redondance >1
		value_nabla=parseFloat(obs.nabla).toFixed(num_decimales)+ add_post(obs.unit_str);//param√®tre de d√©centralit√© 4,1 pour w_max=2,5 et Beta=5%
		value_standardized_residual=parseFloat(obs.standardized_residual).toFixed(num_decimales_mini)+add_post("ùúé");
		if (Math.abs(parseFloat(value_standardized_residual)) > first_step_standardized_residual){ 
			str_gros_residu_class = ' gros';
			if (Math.abs(parseFloat(value_standardized_residual)) >second_step_standardized_residual){
				str_gros_residu_class = ' tres_gros';
        }
        value_probableError=parseFloat(obs.probableError).toFixed(num_decimales)+ add_post(obs.unit_str)
      }
		}else{
			value_nabla="-"
			value_standardized_residual="-"
		}
		if (!data["computation"]["invertedMatrix"]){
			if (Math.abs(parseFloat(obs.normalized_residual)) > first_step_normalized_residual){ 
				str_gros_residu_class = ' gros';
				if (Math.abs(parseFloat(obs.normalized_residual)) > second_step_normalized_residual){
					str_gros_residu_class = ' tres_gros';
				}
			}
		}
  }
  var str_residual_mm = '';
  if (obs.unit_str === 'm')
    str_residual_mm = obs.residual * 1000;
  else
    str_residual_mm = obs.residual * obs.obs_length * obs.unit_factor * 1000;
  str='<tr  class=\"' + parite[i % 2] + str_active_class + '\" id="' + all_files[obs.file] + ':' + obs.line +'">';
  if (isbiggest)
    str+='<td><a href="#' + all_files[all_active_obs[i].file] + ':' + all_active_obs[i].line + '">‚Üë</a>';
  if (obs.from=="?"){
    code_from=undefined;code_to=undefined;
  }else{
    code_from= all_pts_name[obs.from].code; code_to= all_pts_name[obs.to].code;
  }
  var file2tooltip='<br /><span class="file">'+ all_files[obs.file] + ':' + obs.line +'</span>';
  str+= add_code_obs(obs,file2tooltip) +
    '<td class=\"name\">' + add_post(codes_pt[code_from]) + obs.from  +
    '<span class="tooltip">'+_("De") + file2tooltip + '</br>' + add_comment(all_pts_name[obs.from]) + '</span>' + add_circle_comment(all_pts_name[obs.from]) +
    '</td><td class=\"name\">' + add_post(codes_pt[code_to]) + obs.to +
    '<span class="tooltip">'+_("Vers")  + file2tooltip + '</br>' + add_comment(all_pts_name[obs.to]) + '</span>' + add_circle_comment(all_pts_name[obs.to]) +
    '</td><td>' + parseFloat(obs.original_value).toFixed(num_decimales) + add_post(obs.unit_str) +
    '<span class="tooltip">'+_("Mesure") + file2tooltip + '</span>';

// Ajout des colonnes masquables
  var value = {
    "obs_length": parseFloat(obs.obs_length).toFixed(num_decimales)+ add_post("m"),
    "sigma_total": parseFloat(obs.sigma_total).toFixed(num_decimales)+ add_post(obs.unit_str),
    "normalized_residual" :  parseFloat(obs.normalized_residual).toFixed(num_decimales_mini)+ add_post("ùúé"),
    "residual" : parseFloat(obs.residual).toFixed(num_decimales)+ add_post(obs.unit_str),
    "residual_mm" : str_residual_mm.toFixed(num_decimales_mini)+ add_post("mm"),
    "sigma_a_posteriori" : value_sigma_a_posteriori,
    "residualStd" : value_residualStd,
    "standardized_residual" : value_standardized_residual,
    "obsRedondancy" : value_obsRedondancy,
    "nabla": value_nabla,
    "probableError" : value_probableError
  };
  for (var id of id_fold) {
	if ((id=="obs_length")||(id=="sigma_total")){
		str_gros_residu_class_td=''
	}else{
		str_gros_residu_class_td=str_gros_residu_class
	}
    str+='</td><td class="hand '+need_inversion(id)+' '+id+' '+str_gros_residu_class_td+'" onclick="toggle(\''+id+'\')">' + value[id] +
      '<span class="tooltip">'+title_fold[id] + file2tooltip + '<span class="fold"></br>'+_("Cliquer pour plier")+'</span></span></td>';
    str+="</td><td class='mask mask_"+id+"' id="+id+" onclick='toggle(\""+id+"\")'>&#x27A4;&#x27A4;<span class='tooltip'>"+title_fold[id] + '<span class="fold"></br>'+_("Cliquer pour d√©plier")+'</span></span></td>';
  }
  str+='</tr>';
  return str;
}

function show_obs(){
  //write observations ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#obs">' + _('Observations') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: 'Observations',
    id: 'obs'
  }).appendTo('#rapport');
  $("<a/>", {
    href: '#top'
  }).html('&#8593;').appendTo('#obs');
    var items=["<table id='observations_table''> <thead><tr>"];
    get_head_obs(items)
    var last_file = -1;
    var i=1;
    for (var obs of all_obs) {
      i++;
      if (obs.active) {
        all_active_obs.push(obs);
        if ((obs.code === 5) || (obs.code === 7) || (obs.code === 8))
          exist["hz"] = true;
        else if (obs.code === 6)
          exist["zen"] = true;
        else if ((obs.code === 1) || (obs.code === 2) || (obs.code === 3))
          exist["dist"] = true;
        else if ((obs.code >= 101) && (obs.code <= 106))
          exist["basc"] = true;
        else if ((obs.code >= 181) && (obs.code <= 189))
          exist["axis"] = true;
        else if ((obs.code === -1) || (obs.code === -2) || (obs.code === -3))
          exist["coord"] = true;
        else if (obs.code === 4)
          exist["den"] = true;
      }
      if (obs.file !== last_file) {
        last_file = obs.file;
        items.push(' <tr class="filename"><td colspan="15"> <a href="' + all_files[obs.file] + '" download>' + all_files[obs.file] + '</a></td></tr>');
      }
      items.push(obs2tab(obs,i,false));
    }
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
  if (!data["computation"]["invertedMatrix"]) {
    $('.class_need_inversion').remove();
  }
}

function show_repart_residuals(){
  //Charts ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#repart_residuals">' + _('R√©partition des r√©sidus') + '</a>').appendTo('#sommaire');
  //prepare residuals histogram -----------------------
  const residuals_class_width = 0.5;
  var all_residuals_class_labels=["<-3ùúé"];
  var all_residuals_class_val=[0];
  var all_residuals_class_val_hz=[0];
  var all_residuals_class_val_zen=[0];
  var all_residuals_class_val_dist=[0];
  var all_residuals_class_val_den=[0];
  var all_residuals_class_val_bascule=[0];
  var all_residuals_class_val_axe=[0];
  var all_residuals_class_val_coord=[0];
  var all_residuals_class_val_std=[0];
  for (var i = 0; i < 6 / residuals_class_width - 1; i++) {
    var x = -3 + (i + 1) * residuals_class_width;
    all_residuals_class_labels.push(x.toFixed(1) + "ùúé");
    all_residuals_class_val.push(0);
    all_residuals_class_val_hz.push(0);
    all_residuals_class_val_zen.push(0);
    all_residuals_class_val_dist.push(0);
    all_residuals_class_val_den.push(0);
    all_residuals_class_val_bascule.push(0);
    all_residuals_class_val_axe.push(0);
    all_residuals_class_val_coord.push(0);
    //standard: 1/sqrt(2*pi)*e^(-x**2/2)
    all_residuals_class_val_std.push(nb_obs_active / Math.sqrt(2 * Math.PI) * Math.exp(-(x * x / 1)) * residuals_class_width);
  }
  all_residuals_class_labels.push(">3ùúé");
  all_residuals_class_val.push(0);
  all_residuals_class_val_hz.push(0);
  all_residuals_class_val_zen.push(0);
  all_residuals_class_val_dist.push(0);
  all_residuals_class_val_den.push(0);
  all_residuals_class_val_bascule.push(0);
  all_residuals_class_val_axe.push(0);
  all_residuals_class_val_coord.push(0);
  all_residuals_class_val_std.push(0);

  var min_dist = 10000;
  var max_dist = 0;
  for (var active_obs of all_active_obs) {
    var class_num = Math.round((active_obs.normalized_residual + 3) / residuals_class_width);
    class_num = Math.min(class_num, all_residuals_class_labels.length - 1);
    class_num = Math.max(class_num, 0);
    all_residuals_class_val[class_num] += 1;
    //prepare datas for residuals vs distance charts -----------------------
    if ((active_obs.code === 1) || (active_obs.code === 2) || (active_obs.code === 3) ||
      (active_obs.code === 5) || (active_obs.code === 6) ||
      (active_obs.code === 7) || (active_obs.code === 8) ||
      ((active_obs.code >= 101) && (active_obs.code <= 106))) {
      if (active_obs.obs_length > max_dist)
        max_dist = active_obs.obs_length;
      if ((active_obs.obs_length > 0.1) && (active_obs.obs_length < min_dist))
        min_dist = active_obs.obs_length;
    }
    if ((active_obs.code === 5) || (active_obs.code === 7) || (active_obs.code === 8))
      all_residuals_class_val_hz[class_num] += 1;
    else if (active_obs.code === 6)
      all_residuals_class_val_zen[class_num] += 1;
    else if ((active_obs.code === 1) || (active_obs.code === 2) || (active_obs.code === 3))
      all_residuals_class_val_dist[class_num] += 1;
    else if ((active_obs.code >= 101) && (active_obs.code <= 106))
      all_residuals_class_val_bascule[class_num] += 1;
    else if ((active_obs.code >= 181) && (active_obs.code <= 189))
      all_residuals_class_val_axe[class_num] += 1;
    else if ((active_obs.code === -1) || (active_obs.code === -2) || (active_obs.code === -3))
      all_residuals_class_val_coord[class_num] += 1;
    else if (active_obs.code === 4)
      all_residuals_class_val_den[class_num] += 1;
  }
  min_dist-=0.001;
  max_dist+=0.001;

  var all_residuals_class_config = {
    type: 'bar',
    data: {
      labels: all_residuals_class_labels,
      datasets: [{
          label: _("Standard"),
          fill: false,
          backgroundColor: "rgba(120,120,120,1)",
          borderColor: "rgba(120,120,120,1)",
          pointRadius: 0,
          data: all_residuals_class_val_std,
          type: 'line'
        },
        {
          label: _("Tous les r√©sidus"),
          backgroundColor: "rgba(255,162,0,1)",
          borderColor: "rgba(255,162,0,1)",
          pointRadius: 0,
          data: all_residuals_class_val,
        },
      ]
    },
    options: {
      responsive: true,
      title: {
        display: true,
        text: _("R√©partition des r√©sidus normalis√©s")
      },
      showTooltips: false,
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }]
      }
    }
  };

  var dist_chart_num_steps = 10;
  var dist_chart_start_step = min_dist;
  var dist_chart_factor_step = Math.pow((max_dist / dist_chart_start_step), 1 / (dist_chart_num_steps - 1));
  var all_dists = [];
  var dist_residuals_class_labels = [];
  var dist_residuals_class_val_std = [];
  var dist_residuals_class_val_hz = [];
  var dist_residuals_class_val_hz_abs = [];
  var dist_residuals_class_val_hz_num = [];
  var dist_residuals_class_val_hz_et = []; //ecart type
  var dist_residuals_class_val_zen = [];
  var dist_residuals_class_val_zen_abs = [];
  var dist_residuals_class_val_zen_num = [];
  var dist_residuals_class_val_zen_et = [];
  var dist_residuals_class_val_dist_abs = [];
  var dist_residuals_class_val_dist = [];
  var dist_residuals_class_val_dist_num = [];
  var dist_residuals_class_val_dist_et = [];
  var dist_residuals_class_val_basc = [];
  var dist_residuals_class_val_basc_abs = [];
  var dist_residuals_class_val_basc_num = [];
  var dist_residuals_class_val_basc_et = [];
  var dist_residuals_class_val_axe = [];
  var dist_residuals_class_val_axe_abs = [];
  var dist_residuals_class_val_axe_num = [];
  var dist_residuals_class_val_axe_et = [];
  var dist_residuals_all = [];
  var dist = dist_chart_start_step;
  for (var i = 0; i < dist_chart_num_steps + 1; i++) {
    all_dists.push(dist);
    dist_residuals_class_labels.push("<" + dist.toFixed(1) + "m");
    dist_residuals_class_val_std.push(1.0);
    dist_residuals_class_val_hz.push(0);
    dist_residuals_class_val_hz_abs.push(0);
    dist_residuals_class_val_hz_num.push(0);
    dist_residuals_class_val_hz_et.push(0);
    dist_residuals_class_val_zen.push(0);
    dist_residuals_class_val_zen_abs.push(0);
    dist_residuals_class_val_zen_num.push(0);
    dist_residuals_class_val_zen_et.push(0);
    dist_residuals_class_val_dist.push(0);
    dist_residuals_class_val_dist_abs.push(0);
    dist_residuals_class_val_dist_num.push(0);
    dist_residuals_class_val_dist_et.push(0);
    dist_residuals_class_val_basc.push(0);
    dist_residuals_class_val_basc_abs.push(0);
    dist_residuals_class_val_basc_num.push(0);
    dist_residuals_class_val_basc_et.push(0);
    dist_residuals_class_val_axe.push(0);
    dist_residuals_class_val_axe_abs.push(0);
    dist_residuals_class_val_axe_num.push(0);
    dist_residuals_class_val_axe_et.push(0);
    dist *= dist_chart_factor_step;
  }
  for (var active_obs of all_active_obs) {
    var class_num = 0;
    for (var j = 0; j < dist_chart_num_steps - 1; j++) {
      if (active_obs.obs_length > all_dists[j])
        class_num++;
    }
    if ((active_obs.code === 5) || (active_obs.code === 7) || (active_obs.code === 8)) {
      dist_residuals_class_val_hz_num[class_num] += 1;
      dist_residuals_class_val_hz[class_num] += (active_obs.normalized_residual);
      dist_residuals_class_val_hz_abs[class_num] += Math.abs(active_obs.normalized_residual);
    }
    else if (active_obs.code === 6) {
      dist_residuals_class_val_zen_num[class_num] += 1;
      dist_residuals_class_val_zen[class_num] += (active_obs.normalized_residual);
      dist_residuals_class_val_zen_abs[class_num] += Math.abs(active_obs.normalized_residual);
    }
    else if ((active_obs.code === 1) || (active_obs.code === 2) || (active_obs.code === 3)) {
      dist_residuals_class_val_dist_num[class_num] += 1;
      dist_residuals_class_val_dist[class_num] += (active_obs.normalized_residual);
      dist_residuals_class_val_dist_abs[class_num] += Math.abs(active_obs.normalized_residual);
    }
    else if ((active_obs.code >= 101) && (active_obs.code <= 106)) {
      dist_residuals_class_val_basc_num[class_num] += 1;
      dist_residuals_class_val_basc[class_num] += (active_obs.normalized_residual);
      dist_residuals_class_val_basc_abs[class_num] += Math.abs(active_obs.normalized_residual);
    }
    else if ((active_obs.code >= 181) && (active_obs.code <= 189)) {
      dist_residuals_class_val_axe_num[class_num] += 1;
      dist_residuals_class_val_axe[class_num] += (active_obs.normalized_residual);
      dist_residuals_class_val_axe_abs[class_num] += Math.abs(active_obs.normalized_residual);
    }
  }
  for (var i = 0; i < dist_chart_num_steps; i++) {
    if (dist_residuals_class_val_hz_num[i] > 0)
    {
      dist_residuals_class_val_hz[i] /= dist_residuals_class_val_hz_num[i];
      dist_residuals_class_val_hz_abs[i] /= dist_residuals_class_val_hz_num[i];
    }
    //else dist_residuals_class_val_hz[i]=parseFloat("NaN");
    if (dist_residuals_class_val_zen_num[i] > 0)
    {
      dist_residuals_class_val_zen[i] /= dist_residuals_class_val_zen_num[i];
      dist_residuals_class_val_zen_abs[i] /= dist_residuals_class_val_zen_num[i];
    }
    //else dist_residuals_class_val_zen[i]=parseFloat("NaN");
    if (dist_residuals_class_val_dist_num[i] > 0)
    {
      dist_residuals_class_val_dist[i] /= dist_residuals_class_val_dist_num[i];
      dist_residuals_class_val_dist_abs[i] /= dist_residuals_class_val_dist_num[i];
    }
    if (dist_residuals_class_val_basc_num[i] > 0)
    {
      dist_residuals_class_val_basc[i] /= dist_residuals_class_val_basc_num[i];
      dist_residuals_class_val_basc_abs[i] /= dist_residuals_class_val_basc_num[i];
    }
    if (dist_residuals_class_val_axe_num[i] > 0)
    {
      dist_residuals_class_val_axe[i] /= dist_residuals_class_val_axe_num[i];
      dist_residuals_class_val_axe_abs[i] /= dist_residuals_class_val_axe_num[i];
    }
    //else dist_residuals_class_val_dist[i]=parseFloat("NaN");
  }
  for (var active_obs of all_active_obs) {
    var class_num = 0;
    for (var j = 0; j < dist_chart_num_steps - 1; j++) {
      if (active_obs.obs_length > all_dists[j])
        class_num++;
    }
    if ((active_obs.code === 5) || (active_obs.code === 7) || (active_obs.code === 8)) {
      dist_residuals_class_val_hz_et[class_num] += Math.abs(active_obs.normalized_residual - dist_residuals_class_val_hz[class_num]);
    }
    else if (active_obs.code === 6) {
      dist_residuals_class_val_zen_et[class_num] += Math.abs(active_obs.normalized_residual - dist_residuals_class_val_zen[class_num]);
    }
    else if ((active_obs.code === 1) || (active_obs.code === 2) || (active_obs.code === 3)) {
      dist_residuals_class_val_dist_et[class_num] += Math.abs(active_obs.normalized_residual - dist_residuals_class_val_dist[class_num]);
    }
    else if ((active_obs.code >= 101) && (active_obs.code <= 106)) {
      dist_residuals_class_val_basc_et[class_num] += Math.abs(active_obs.normalized_residual - dist_residuals_class_val_basc[class_num]);
    }
    else if ((active_obs.code >= 181) && (active_obs.code <= 189)) {
      dist_residuals_class_val_axe_et[class_num] += Math.abs(active_obs.normalized_residual - dist_residuals_class_val_axe[class_num]);
    }
  }
  for (var i = 0; i < dist_chart_num_steps; i++) {
    if (dist_residuals_class_val_hz_num[i] > 0)
      dist_residuals_class_val_hz_et[i] /= dist_residuals_class_val_hz_num[i];
    if (dist_residuals_class_val_zen_num[i] > 0)
      dist_residuals_class_val_zen_et[i] /= dist_residuals_class_val_zen_num[i];
    if (dist_residuals_class_val_dist_num[i] > 0)
      dist_residuals_class_val_dist_et[i] /= dist_residuals_class_val_dist_num[i];
    if (dist_residuals_class_val_basc_num[i] > 0)
      dist_residuals_class_val_basc_et[i] /= dist_residuals_class_val_basc_num[i];
    if (dist_residuals_class_val_axe_num[i] > 0)
      dist_residuals_class_val_axe_et[i] /= dist_residuals_class_val_axe_num[i];
  }
  //Fill of the tables (if obs type exists) to draw graphes type-based normalized residual repartition and distance normalized residual repartition
  var data2graph_type = []
  var data2graph_dist = []
  if (exist["hz"]) {
    data2graph_type.push({
      label: _("Horizontales"),
      backgroundColor: "rgba(0,180,180,1)",
      borderColor: "rgba(100,180,180,1)",
      pointRadius: 0,
      data: all_residuals_class_val_hz,
    });
    data2graph_dist.push({
      label: _("Horizontales"),
      backgroundColor: "rgba(0,180,180,1)",
      borderColor: "rgba(100,180,180,1)",
      pointRadius: 0,
      data: dist_residuals_class_val_hz_abs,
    })
    dist_residuals_all.push([dist_residuals_class_val_hz, dist_residuals_class_val_hz_num, dist_residuals_class_val_hz_et, dist_residuals_class_val_hz_abs]);
  }
  if (exist["zen"]) {
    data2graph_type.push({
      label: _("Z√©nithales"),
      backgroundColor: "rgba(0,220,0,1)",
      borderColor: "rgba(100,220,100,1)",
      pointRadius: 0,
      data: all_residuals_class_val_zen,
    });
    data2graph_dist.push({
      label: _("Z√©nithales"),
      backgroundColor: "rgba(0,220,0,1)",
      borderColor: "rgba(100,220,100,1)",
      pointRadius: 0,
      data: dist_residuals_class_val_zen_abs,
    })
    dist_residuals_all.push([dist_residuals_class_val_zen, dist_residuals_class_val_zen_num, dist_residuals_class_val_zen_et, dist_residuals_class_val_zen_abs]);
  }
  if (exist["dist"]) {
    data2graph_type.push({
      label: _("Distances"),
      backgroundColor: "rgba(0,0,220,1)",
      borderColor: "rgba(100,100,220,1)",
      pointRadius: 0,
      data: all_residuals_class_val_dist,
    });
    data2graph_dist.push({
      label: _("Distances"),
      backgroundColor: "rgba(0,0,220,1)",
      borderColor: "rgba(100,100,220,1)",
      pointRadius: 0,
      data: dist_residuals_class_val_dist_abs,
    })
    dist_residuals_all.push([dist_residuals_class_val_dist, dist_residuals_class_val_dist_num, dist_residuals_class_val_dist_et, dist_residuals_class_val_dist_abs]);
  }
  if (exist["basc"]) {
    data2graph_type.push({
      label: _("Bascules"),
      backgroundColor: "rgba(200,0,200,1)",
      borderColor: "rgba(200,100,200,1)",
      pointRadius: 0,
      data: all_residuals_class_val_bascule,
    });
    data2graph_dist.push({
      label: _("Bascules"),
      backgroundColor: "rgba(200,0,200,1)",
      borderColor: "rgba(200,100,220,1)",
      pointRadius: 0,
      data: dist_residuals_class_val_basc_abs,
    })
    dist_residuals_all.push([dist_residuals_class_val_basc, dist_residuals_class_val_basc_num, dist_residuals_class_val_basc_et, dist_residuals_class_val_basc_abs]);
  }
  if (exist["axis"]) {
    data2graph_type.push({
      label: _("Axes"),
      backgroundColor: "rgba(200,0,200,1)",
      borderColor: "rgba(200,100,200,1)",
      pointRadius: 0,
      data: all_residuals_class_val_axe,
    });
    data2graph_dist.push({
      label: _("Axes"),
      backgroundColor: "rgba(200,0,200,1)",
      borderColor: "rgba(200,100,220,1)",
      pointRadius: 0,
      data: dist_residuals_class_val_axe_abs,
    })
    dist_residuals_all.push([dist_residuals_class_val_axe, dist_residuals_class_val_axe_num, dist_residuals_class_val_axe_et, dist_residuals_class_val_axe_abs]);
  }
  if (exist["coord"]) {
    data2graph_type.push({
      label: _("Coord"),
      backgroundColor: "rgba(200,200,0,1)",
      borderColor: "rgba(200,200,100,1)",
      pointRadius: 0,
      data: all_residuals_class_val_coord,
    })
  }
  if (exist["den"]) {
    data2graph_type.push({
      label: _("D√©nivel√©es"),
      backgroundColor: "rgba(255,215,0,1)",
      borderColor: "rgba(255,215,0,1)",
      pointRadius: 0,
      data: all_residuals_class_val_den,
    })
  }

  //prepare type-based normalized residual repartition charts -----------------------
  var all_residuals_class_config_type = {
    type: 'bar',
    data: {
      labels: all_residuals_class_labels,
      datasets: data2graph_type
    },
    options: {
      responsive: true,
      title: {
        display: true,
        text: _("R√©partition des r√©sidus normalis√©s par type")
      },
      showTooltips: false,
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }]
      }
    }
  };

  //prepare residuals vs distance charts -----------------------
  var dist_residuals_class_config_type = {
    type: 'bar',
    data: {
      labels: dist_residuals_class_labels,
      datasets: data2graph_dist
    },
    options: {
      responsive: true,
      title: {
        display: true,
        text: _("R√©sidus absolus moyens par rapport √† la distance")
      },
      showTooltips: true,
      tooltips: {
        callbacks: {
          label: function(tooltipItem, data) {
            return " Abs" + _(" :") + dist_residuals_all[tooltipItem.datasetIndex][3][tooltipItem.index].toFixed(2) + "ùúé  | NoAbs" + _(" :") +
              dist_residuals_all[tooltipItem.datasetIndex][0][tooltipItem.index].toFixed(2) + "ùúé +/-" +
              dist_residuals_all[tooltipItem.datasetIndex][2][tooltipItem.index].toFixed(2) +
              "ùúé | NbObs" + _(" :") + dist_residuals_all[tooltipItem.datasetIndex][1][tooltipItem.index];
            //return tooltipItem.index+" "+tooltipItem.datasetIndex;//Object.keys(tooltipItem);
            //return data.datasets[0].data[0];//Object.keys(data);
          }
        }
      },
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          },
          ticks: {
            callback: function(value, index, values) {
              return value.toFixed(2) + "ùúé";
            },
          }
        }]
      }
    }
  };
  //write charts ------------------------------------------------------------------------------------
  $("<h2/>", {
    text: _('R√©partition des r√©sidus'),
    id: 'repart_residuals'
  }).appendTo('#rapport');
  $("<table id='residuals_charts'/>").html("<tr><td><canvas id='residuals_chart' width='400' height='300'/></td>" +
    "<td><canvas id='residuals_chart_type' width='400' height='300'/></td></tr>").appendTo('#rapport');
  var ctx2 = $("#residuals_chart").get(0).getContext("2d");
  var myNewChart2 = new Chart(ctx2, all_residuals_class_config);
  var ctx3 = $("#residuals_chart_type").get(0).getContext("2d");
  var myNewChart3 = new Chart(ctx3, all_residuals_class_config_type);
  $("<table id='dist_residuals_charts_type'/>").html("<tr><td><canvas id='dist_residuals_chart_type' width='800' height='300'/></td></tr>").appendTo('#rapport');
  var ctx4 = $("#dist_residuals_chart_type").get(0).getContext("2d");
  var myNewChart4 = new Chart(ctx4, dist_residuals_class_config_type);
}

function show_pseudo(){
  $("<p/>").html('<a href="#propositions_pseudo_aleatoires">' + _('Propositions pseudo al√©atoires') + '</a>').appendTo('#sommaire');
  var sum_sigma = {};
  sum_sigma["hz"]=0;sum_sigma["zen"]=0;sum_sigma["dist"]=0;sum_sigma["basc"]=0;sum_sigma["axis"]=0;sum_sigma["coord"]=0;sum_sigma["den"]=0;
  var num_type = {};
  num_type["hz"]=0;num_type["zen"]=0;num_type["dist"]=0;num_type["basc"]=0;num_type["axis"]=0;num_type["coord"]=0;num_type["den"]=0;
  var red = {};
  red["hz"]=0;red["zen"]=0;red["dist"]=0;red["basc"]=0;red["axis"]=0;red["coord"]=0;red["den"]=0;
  var nb_red = {};
  nb_red["hz"]=0;nb_red["zen"]=0;nb_red["dist"]=0;nb_red["basc"]=0;nb_red["axis"]=0;nb_red["coord"]=0;nb_red["den"]=0;
  var sigma = {};
  var pseudo = {};
  
  for (var obs of all_obs){
    if (obs.active){
      type=type_obs[obs.code];
      sum_sigma[type]+=Math.abs(obs.normalized_residual)*(obs.obsRedondancy/100);
      num_type[type]+=1;
      red[type]+=obs.obsRedondancy/100;
      if (obs.obsRedondancy > 80){
        nb_red[type]+=1;
      }
    }
  }
  red_tot=red["hz"]+red["zen"]+red["dist"]+red["basc"]+red["axis"]+red["coord"]+red["den"];
  sum_sigma_n=sum_sigma["hz"]+sum_sigma["zen"]+sum_sigma["dist"]+sum_sigma["basc"]+sum_sigma["axis"]+sum_sigma["coord"]+sum_sigma["den"];
  mu=sum_sigma_n/parseFloat(data["computation"]["sigma_0_final"]);

  $("<h2/>",{
  html: _('Propositions pseudo al√©atoires'),
  id: 'propositions_pseudo_aleatoires'
  }).appendTo('#rapport');
  $("<h4/>",{
  html: _('Redondance totale du syst√®me : ')+red_tot.toFixed(0),
  title: _('Somme des redondances partielles correspondant au degr√© de libert√© du syst√®me'),
  }).appendTo('#rapport');
  $("<p/>",{
  html: _('Il faudrait mutiplier les sigmas des observations par :'),
  }).appendTo('#rapport');
  
  not_enough=_("Pas assez d'observations");
  not_enough_red=_("Pas assez de redondance");
  for (type in exist){
    var warning="";
    var post='post="&nbsp;&nbsp;&#9432;"';
    if (exist[type]){
      var av_red=red[type]/num_type[type]*100
      if (num_type[type]<10){
        pseudo[type]=not_enough;
      }else if (av_red<30){
        warning="&#9888; "+_("La moyenne des redondances partielles de ce type est inf√©rieure √† 30%");
        post='warn_post="&nbsp;&nbsp;&#9888;"';
        pseudo[type]=not_enough_red;
      }else{
        sigma[type]=sum_sigma[type]/red[type];
        pseudo[type]= parseFloat((sigma[type]/mu)*(red_tot)).toFixed(num_decimales);
      }
      items=[];
      items.push(nom_type[type] + _(" :") + " " + pseudo[type] + '<span class="tooltipp" '+post+'>'+
      '<span class="tooltipptext">'+_("Nombre d'observations de ce type : ") + num_type[type] + _(" dont ") + nb_red[type] + _(" redondantes")+
      '<span class="sum_red"></br>'+_("Somme des redondances partielles de ce type : ")+red[type].toFixed(0)+" "+_("soit")+" "+(red[type]/red_tot*100).toFixed(0)+" % "+_("de la redondance totale")+'</span>'+
      '<span class="av_red"></br>'+_("Moyenne des redondances partielles de ce type : ")+av_red.toFixed(0)+' %</span>'+
      '<span class="warn_red"></br>'+ warning+'</span>'+
      '</span></span>')
      $('<p/>',{
        html: items.join('')
      }).appendTo('#rapport');
    }
  }
}

function show_biggest_residuals(){
  $("<p/>").html('<a href="#biggest_residuals">' + _('Plus gros r√©sidus') + '</a>').appendTo('#sommaire');
  //write biggest residuals ------------------------------------------------------------------------------------
	title_biggest_residual=""
  if (data["computation"]["invertedMatrix"]){
		$("<h2/>", {
			text: _('Plus gros r√©sidus'),
			id: 'biggest_residuals',
			title: _("les 20 plus gros r√©sidus norm√©s du plus grand au plus petit")
		}).appendTo('#rapport');
	}else{
		$("<h2/>", {
			text: _('Plus gros r√©sidus'),
			id: 'biggest_residuals',
			title: _("les 20 plus gros r√©sidus normalis√©s du plus grand au plus petit")
		}).appendTo('#rapport');
	}
  items = ["<table id='biggest_residuals_table'><thead><tr><th width=3%>"];
  get_head_obs(items)
  all_active_obs.sort(residualSortFunction);
  for (var i = 0; i < Math.min(max_biggest_residuals, nb_obs_active); i++)
    if (residual_is_big(all_active_obs[i]))
      items.push(obs2tab(all_active_obs[i],i,true));
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
  if (!data["computation"]["invertedMatrix"]){
    $('.class_need_inversion').remove();
  }
}

function show_bascules(){
  $("<p/>").html('<a href="#basc">' + _('Bascules') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Bascules'),
    id: 'basc'
  }).appendTo('#rapport');
  var triplet_types = {
    11: "cart obs",
    12: "angl obs"
  };
  items = ["<tr><th class=\"name\">" + _("Nom fichier") +
  "</th><th>" + _("Point origine") +
  "</th><th>" + _("Verticale") +
  "</th><th></th> <th colspan=\"3\">" + _("Coordonn√©es cart√©siennes globales") + " (m)</th></tr>"];
  for (var i = 0; i < all_basc.length; i++) {
    var basc = all_basc[i];
    var origin = all_basc[i].origin;
    var pos = origin["coord_compensated_cartesian"];
    var matrix = basc["params"]["R_global2instr"];
    var obs_type = triplet_types[basc["triplet_type"]];
    items.push('<tr class=\"' + parite[i % 2] + '\"><td class=\"name\" rowspan=\"2\">' + all_files[basc["observations"][0].file] +
               '</td><td class=\"name\" rowspan=\"4\">' + basc.name + '</td>');
    items.push('<td rowspan=\"2\" >' + bool(basc.vertical) + '</td>');
    items.push('<td  class=\"name\"> Vect </td><td>' + parseFloat(pos[0]).toFixed(num_decimales) +
               '</td><td>' + parseFloat(pos[1]).toFixed(num_decimales) +
               '</td><td>' + parseFloat(pos[2]).toFixed(num_decimales) + '</td>');
    items.push('</tr>');
    items.push('<tr class=\"' + parite[i % 2] + '\"><td rowspan=\"3\"  class=\"name\"> Mat </td>');
    items.push('<td>' + parseFloat(matrix[0]).toFixed(num_decimales) +
               '</td><td>' + parseFloat(matrix[1]).toFixed(num_decimales) +
               '</td><td>' + parseFloat(matrix[2]).toFixed(num_decimales) + '</td></tr>');
    items.push('<tr class=\"' + parite[i % 2] + '\"><td rowspan=\"2\">' + obs_type +
               '</td><td>' + _("D√©viation") +
               '</td><td>' + parseFloat(matrix[3]).toFixed(num_decimales) +
               '</td><td>' + parseFloat(matrix[4]).toFixed(num_decimales) +
               '</td><td>' + parseFloat(matrix[5]).toFixed(num_decimales) + '</td></tr>');
    items.push('<tr class=\"' + parite[i % 2] + '\"><td>' + parseFloat(basc.ang_to_vert).toFixed(num_decimales) + add_post(data["computation"]["unit_name"]) + '</td><td>' + parseFloat(matrix[6]).toFixed(num_decimales) + '</td><td>' + parseFloat(matrix[7]).toFixed(num_decimales) + '</td><td>' + parseFloat(matrix[8]).toFixed(num_decimales) + '</td></tr>');
  }
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
}

function show_axes(){
  $("<p/>").html('<a href="#axes">' + _('Axes') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Axes'),
    id: 'axes'
  }).appendTo('#rapport');
  
  for (var i = 0; i < all_axes.length; i++) {
    var axe = all_axes[i];
    var origin = all_axes[i].origin;
    var pos = origin["coord_compensated_cartesian"];
    var prec_a="";
    var prec_b="";
    var prec_c="";
    if (data["computation"]["invertedMatrix"]) {
        prec_a=" &plusmn; "+axe.params_sigmas.sigma_a.toFixed(num_decimales);
        prec_b=" &plusmn; "+axe.params_sigmas.sigma_b.toFixed(num_decimales);
        prec_c=" &plusmn; "+axe.params_sigmas.sigma_c.toFixed(num_decimales);
    }

    items = ["<h3>"+_("Axe ")+'<a href="' + all_files[axe["observations"][0].file] + '" download>' + all_files[axe["observations"][0].file] + '</a>'+_(" sur point ")+axe.name+"</h3>"];
    items.push("<table>");
    items.push("<tr><th class=\"name\" colspan=\"3\">" + _("Param√©trage de l'axe")+"</th></tr>")
    items.push("<tr><td>" + axe.params.a.toFixed(num_decimales) + prec_a + "</td><td>" +            "</td><td>" + pos[0].toFixed(num_decimales) + "</td></tr>"
             + "<tr><td>" + axe.params.b.toFixed(num_decimales) + prec_b + "</td><td>" + " * Œª + "+ "</td><td>" + pos[1].toFixed(num_decimales) + "</td></tr>"
             + "<tr><td>" + axe.params.c.toFixed(num_decimales) + prec_c + "</td><td>" +            "</td><td>" + pos[2].toFixed(num_decimales) + "</td></tr>");
    items.push("</table>");
    items.push("<table>");
    items.push("<tr><th class=\"name\">" + _("ID cible ")+"</th><th>"+_("Abscisse")+"</th><th>"+_("Rayon")+"</th><th>"+_("Positions")+"</th></tr>");
    for (var j = 0; j < axe.targets.length; j++){
        var target=axe.targets[j];
        items.push("<tr><td lass=\"name\">" + target.num+"</td><td>"+target.params.l.toFixed(num_decimales)
            +"</td><td>"+target.params.r.toFixed(num_decimales)
            +"</td><td>"+target.axisObs.length
            +"</td></tr>");
    }
    items.push("</table>");
    $('<div/>', {
      'class': 'points',
      html: items.join('')
    }).appendTo('#rapport');
  }
}

function show_coord_comp(){
  $("<p/>").html('<a href="#coord_comp">' + _('Coordonn√©es compens√©es') + '</a>').appendTo('#sommaire');
  $("<h2/>",{
    text: _('Coordonn√©es compens√©es'),
    id: 'coord_comp'
  }).appendTo('#rapport');
  items = ["<tr><th class=\"name\">" + _("Nom")+'</th>'];
  var composant;
  if (data["config"]["use_proj"]){
    composant=["E","N"];
  }else{
    composant=["X","Y"];
  }
  if (data["config"]["use_ellips_height"])
    composant.push(_("He"));
  else
    composant.push(_("Alti"));
  items.push("<th>" + composant[0] + " comp" +
    "</th><th>" + composant[1] + " comp" +
    "</th><th>" + composant[2] + " comp" +
    "</th><th>" + "&Delta;" + composant[0] +
    "</th><th>" + "&Delta;" + composant[1] +
    "</th><th>" + "&Delta;Z");
  items.push("</th><th>" + "&sigma;X init" +
    "</th><th>" + "&sigma;Y init" +
    "</th><th>" + "&sigma;Z init");
  items.push(get_head_dev());
  items.push("</th><th class='small' title='"+_('Nombre d&apos;observations actives en lien avec le point')+"'>" + _("Obs actives") +"</th></tr>");
  for (var i = 0; i < nb_pts; i++){
    var pt = all_pts[i];
    coord_compensated=[];
    items.push(add_name(pt,i,1));
    if (data["config"]["use_proj"]){
      coord_compensated=pt.coord_compensated_georef;
    }else{
      coord_compensated=pt.coord_compensated_stereographic;
    }
    items.push('</td><td>' + parseFloat(coord_compensated[0]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ composant[0] + ' comp</span>' +
              '</td><td>' + parseFloat(coord_compensated[1]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ composant[1] + ' comp</span>' +
              '</td><td>' + parseFloat(coord_compensated[2]).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ composant[2] + ' comp</span></td>');
    if (pt.dimension === 3){
      items.push('<td>' + (parseFloat(pt.shift_from_read[0])).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ "&Delta;" + composant[0] + '</span></td>' +
                '<td>' + (parseFloat(pt.shift_from_read[1])).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ "&Delta;" + composant[1] + '</span></td>' +
                '<td>' + (parseFloat(pt.shift_from_read[2])).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ "&Delta;Z" + '</span></td>');
    }else if (pt.dimension === 2){
      items.push('<td>' + (parseFloat(pt.shift_from_read[0])).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ "&Delta;" + composant[0] + '</span>' +
            '</td><td>' + (parseFloat(pt.shift_from_read[1])).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ "&Delta;" + composant[1] + '</span>' +
            '</td><td>-<span class="tooltip">'+ "&Delta;Z" + '</span></td>');
    }else{
      items.push('<td>-<span class="tooltip">'+ "&Delta;" + composant[0] + '</span>' +
            '</td><td>-<span class="tooltip">'+ "&Delta;" + composant[1] + '</span>' +
            '</td><td>' + (parseFloat(pt.shift_from_read[2])).toFixed(num_decimales) + add_post("m") + '<span class="tooltip">'+ "&Delta;Z" + '</span></td>');
    }
    items.push(point_sigmas(pt));
    items.push(get_dev(pt));
    items.push('<td class="small">' + pt.nbActiveObs + '<span class="tooltip">'+_('Nombre d&apos;observations actives en lien avec le point') + '</span></td></tr>');
  }
  $('<table/>',{
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
}

function show_ellips(){
  $("<p/>").html('<a href="#ellips">' + _('Ellipso√Ødes de confiance') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Ellipso√Ødes de confiance'),
    id: 'ellips'
  }).appendTo('#rapport');
  items = ["<tr><th class=\"name\">" + _("Nom") +
  "</th><th>" + _("1/2 Axe (mm)") +
  "</th><th>" + _("Gisement (gr)") +
  "</th><th>" + _("Site (gr)") + "</th></tr>"];
  for (var i = 0; i < nb_pts; i++) {
    var pt = all_pts[i];
    if (pt.dimension === 1)
    //Points 1D == Z
    {
      items.push(add_name(pt,i,1));
      items.push('<td>' +
        parseFloat(pt.ellips.axes[0][0] * 1000).toFixed(num_decimales_mini + 1) + '</td><td>-</td><td>' +
        parseFloat(pt.ellips.axes[0][2]).toFixed(num_decimales_mini + 1) + '</td></tr>');
    } else if (pt.dimension === 2){
      items.push(add_name(pt,i,2));
      items.push('<td>' +
        parseFloat(pt.ellips.axes[0][0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("1/2 Axe (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[0][1]).toFixed(num_decimales) + '<span class="tooltip">'+_("Gisement (gr)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[0][2]).toFixed(num_decimales) + '<span class="tooltip">'+_("Site (gr)") + '</span></td>');
      items.push('</tr>');
      items.push('<tr class=\"' + parite[i % 2] + '\" >');
      items.push('<td>' +
        parseFloat(pt.ellips.axes[1][0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("1/2 Axe (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[1][1]).toFixed(num_decimales) + '<span class="tooltip">'+_("Gisement (gr)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[1][2]).toFixed(num_decimales) + '<span class="tooltip">'+_("Site (gr)") + '</span></td>');
      items.push('</tr>');
    } else if (pt.dimension === 3){
      items.push(add_name(pt,i,3));
      items.push('<td>' +
        parseFloat(pt.ellips.axes[0][0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("1/2 Axe (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[0][1]).toFixed(num_decimales) + '<span class="tooltip">'+_("Gisement (gr)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[0][2]).toFixed(num_decimales) + '<span class="tooltip">'+_("Site (gr)") + '</span></td>');
      items.push('</tr>');
      items.push('<tr class=\"' + parite[i % 2] + '\" >');
      items.push('<td>' +
        parseFloat(pt.ellips.axes[1][0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("1/2 Axe (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[1][1]).toFixed(num_decimales) + '<span class="tooltip">'+_("Gisement (gr)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[1][2]).toFixed(num_decimales) + '<span class="tooltip">'+_("Site (gr)") + '</span></td>');
      items.push('</tr>');
      items.push('<tr class=\"' + parite[i % 2] + '\" >');
      items.push('<td>' +
        parseFloat(pt.ellips.axes[2][0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("1/2 Axe (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[2][1]).toFixed(num_decimales) + '<span class="tooltip">'+_("Gisement (gr)") + '</span></td><td>' +
        parseFloat(pt.ellips.axes[2][2]).toFixed(num_decimales) + '<span class="tooltip">'+_("Site (gr)") + '</span></td>');
      items.push('</tr>');
    }
  }
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
}

function show_intervalles(){
  //write sigmas ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#interv">' + _('Demi-intervalles de confiance') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Demi-intervalles de confiance'),
    id: 'interv',
    title: _('Demi-intervalles de confiance 1D √† 1 ùúé (68%)')
  }).appendTo('#rapport');
  items = ["<tr><th class=\"name\">" + _("Nom")+"</th>"];
  items.push("<th>" + _("&sigma;X (mm)") +
    "</th><th>" + _("&sigma;Y (mm)") +
    "</th><th>" + _("&sigma;Z (mm)") +
    "</th></tr>");
  for (var i = 0; i < nb_pts; i++) {
    var pt = all_pts[i];
    items.push(add_name(pt,i,1));
    if (pt.dimension === 1) {    //Points 1D == Z
      items.push('<td>-</td><td>-</td><td>' +
        parseFloat(pt.ellips.sigmas[0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("&sigma;Z (mm)") + '</span></td></tr>');
    } else if (pt.dimension === 2){
      items.push('<td>' +
        parseFloat(pt.ellips.sigmas[0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("&sigma;X (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.sigmas[1] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("&sigma;Y (mm)") + '</span></td><td>-</td></tr>');
    } else if (pt.dimension === 3){
      items.push('<td>' +
        parseFloat(pt.ellips.sigmas[0] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("&sigma;X (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.sigmas[1] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("&sigma;Y (mm)") + '</span></td><td>' +
        parseFloat(pt.ellips.sigmas[2] * 1000).toFixed(num_decimales_mini) + '<span class="tooltip">'+_("&sigma;Z (mm)") + '</span></td></tr>');
    }
  }
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
}

function show_deplacements(){
  //Simulation des d√©placements des points (Monte-Carlo) ------------------------------------------------------------------------------------
  $("<p/>").html('<a href="#deplacements">' + _('Simulation des d√©placements des points') + '</a>').appendTo('#sommaire');
  $("<h2/>", {
    text: _('Simulation des d√©placements des points'),
    id: 'deplacements'
  }).appendTo('#rapport');
  $("<p/>", {
    text: _('Pour ') + parseInt(data["computation"]["nbr_iterations"]) + _(' simulations :')
  }).appendTo('#rapport');
  items = ["<tr><th class=\"name\">" + _("Nom") +
  "</th><th>" + _("EMQ X (mm)") +
  "</th><th>" + _("EMQ Y (mm)") +
  "</th><th>" + _("EMQ Z (mm)") +
  "</th>><th>" + _("Max X (mm)") +
  "</th>><th>" + _("Max Y (mm)") +
  "</th>><th>" + _("Max Z (mm)") + "</th></tr>"];
  for (var i = 0; i < nb_pts; i++) {
    var pt = all_pts[i];
    items.push('<tr class=\"' + parite[i % 2] + '\"><td class=\"name\">' + add_post(codes_pt[pt.code]) + pt.name + '</td><td>');
    if ((pt.code === 4)||(pt.code === 5))
      items.push(
        '-</td><td>' +
        '-</td><td>' +
        parseFloat(pt.MC_shift_sq_average[2] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
       '-</td><td>' +
       '-</td><td>' +
        parseFloat(pt.MC_shift_max[2] * 1000).toFixed(num_decimales_mini) + '</td>'
      );
    else if (pt.code >= 6)
      items.push(
      parseFloat(pt.MC_shift_sq_average[0] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_sq_average[1] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      '-</td><td>' +
      parseFloat(pt.MC_shift_max[0] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_max[1] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      '-</td>');
    else
      items.push(
      parseFloat(pt.MC_shift_sq_average[0] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_sq_average[1] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_sq_average[2] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_max[0] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_max[1] * 1000).toFixed(num_decimales_mini) + '</td><td>' +
      parseFloat(pt.MC_shift_max[2] * 1000).toFixed(num_decimales_mini) + '</td>');
    items.push('</tr>');
  }
  $('<table/>', {
    'class': 'points',
    html: items.join('')
  }).appendTo('#rapport');
}

function show_footer(){
  //Pied de page ------------------------------------------------------------------------------------
  $("<p/>", {
    text: 'Copyright ¬© 2013-2021 - IGN/SGM/Travaux Sp√©ciaux - travaux.speciaux@ign.fr',
    class: 'footer'
  }).appendTo('#rapport');
}

//------------------------------------------------------------------------------
// Fonctions de lancement de l'√©criture des diff√©rentes parties si c'est n√©cessaire
//------------------------------------------------------------------------------
function showComp3Djson(data) {
  $("#title").text(data["config"]["name"]);
  num_decimales = parseInt(data["config"]["nb_digits"]);
  num_decimales_mini = Math.max(num_decimales - 3, 0);
  const lang = data["config"]["lang"];
  if (lang in translations)
    current_dict= translations[lang];
  if (data["points"]){
    $.each(data["points"], function(key, val) {
      all_pts.push(val);
      all_pts_name[key]=val;
      $(all_pts).get(-1).name = key;
      if (val["stations"]) {
        $.each(val["stations"], function(key2, val2) {
          $.each(val2["observations"], function(key3, val3) {
            if (!(val3.active&&(val3.rank<0))) all_obs.push(val3); //ne pas afficher les obs non utilisees
          });
          if (val2["type"] === "bascule") {
            all_basc.push(val2);
            $(all_basc).get(-1).name = key;
            $(all_basc).get(-1).origin = val;
          }
          if (val2["type"] === "axis") {
            all_axes.push(val2);
            $(all_axes).get(-1).name = key;
            $(all_axes).get(-1).origin = val;
          }
        });
      }
    });
  }
  if (data["computation"]){
    if (data["computation"]["ICobs"]){
      $.each(data["computation"]["ICobs"], function(key, val) {
        all_obs.push(val);
      });
    }
  }else
      return;
  nb_pts=all_pts.length;
  all_pts.sort(pointSortFunction);
  all_obs.sort(obsSortFunction);
  all_files = data["all_data_files"];
  var nbFiles = 0;
  for (var o in all_files) ++nbFiles;
  nb_obs_active=parseInt(data["computation"]["nbr_active_obs"])
  title_fold = {
    "obs_length": _("Distance"), //_() is here only to generate list of translations
    "sigma_total": _("&sigma; total"),
    "normalized_residual" :  _("R√©sidu normalis√©"),
    "residual" : _("R√©sidu"),
    "residual_mm" : _("R√©sidu mm"),
    "sigma_a_posteriori" : _("&sigma; a posteriori"),
    "residualStd" : _("R√©sidu standard"),
    "obsRedondancy" : _("Redondance"),
    "standardized_residual" : _("R√©sidu norm√©"),
    "nabla":"&nabla;",
    "probableError" : _("Faute probable"),
  };
  nom_type = {
    "dist": _('Distances'),
    "hz": _('Angles horizontaux'),
    "zen" :  _('Angles z√©nithaux'),
    "den" : _('D√©nivel√©es'),
    "coord" : _('Coordonn√©es'),
    "basc" : _('Bascules'),
    "axis" : _('Axes'),
  };
  unit = {
    "0": _("Radians"),
    "1": _("Grades"),
    "2": _("Degr√©s"),
    "3": _("DMS")
  };
  type_calcul = {
    "0": _("Compensation"),
    "1": _("Simulation propagation"),
    "2": _("Simulation Monte-Carlo")
  };
  show_version();
  $('<div class="sommaire" id="sommaire" /div>').appendTo('body');
  $('<img src=\"res/logo_IGN.jpg\" alt=\"IGN\" width="50%"/><img src=\"res/logo_comp.png\" alt=\"Comp3D\" width="50%"/>').appendTo('#sommaire');
  $("<a href='#top'><h1>"+title+"</h1></a>").appendTo('#sommaire');
  $('<div id="rapport" /div>').appendTo('body');
  show_info_work();
  createMap();
  show_info_calc();
  if ((data["config"]["compute_type"] === 0) && (data["computation"]["all_sigma0"].length>0)) {
    show_evol_sigma0();
    show_chi2();
  }
  show_coord_init();
  show_obs();
  if (data["config"]["compute_type"] === 0) {
    show_repart_residuals();
  }
  if ((data["config"]["compute_type"] === 0) && (data["computation"]["invertedMatrix"])) {
    show_pseudo();
  }
  if (data["config"]["compute_type"] === 0) {
    show_biggest_residuals();
  }
  set_display_column();
  if (all_basc.length > 0) {
    show_bascules();
  }
  if (all_axes.length > 0) {
    show_axes();
  }
  if ((data["computation"]["compensationDone"]) && (data["config"]["compute_type"] === 0)) {
    show_coord_comp();
  }
  if (data["computation"]["invertedMatrix"]) {
    show_ellips();
    show_intervalles();
  }
  if (data["config"]["compute_type"] === 2) {
    show_deplacements();
  }
  show_footer();
}

function createMap() {
  $('<div/>', {
    'id': 'mapid',
  }).appendTo('#rapport');

  var markerIconF = L.icon({
    iconUrl: 'res/marker_f.png',
    iconSize:     [16, 16], // size of the icon
    iconAnchor:   [8, 8], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  var markerIconS = L.icon({
    iconUrl: 'res/marker_s.png',
    iconSize:     [16, 16], // size of the icon
    iconAnchor:   [8, 8], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  var markerIconT = L.icon({
    iconUrl: 'res/marker_t.png',
    iconSize:     [16, 16], // size of the icon
    iconAnchor:   [8, 8], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  var markerIconR1 = L.icon({
    iconUrl: 'res/marker_r1.png',
    iconSize:     [32, 32], // size of the icon
    iconAnchor:   [16, 16], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  var markerIconR2 = L.icon({
    iconUrl: 'res/marker_r2.png',
    iconSize:     [32, 32], // size of the icon
    iconAnchor:   [16, 16], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });

  var all_latlong = [];
  var key="coord_compensated_cartesian";

  if (data["computation"]["projection"]["is_georef"])
  {
      mymap = L.map('mapid');
      key="coord_compensated_latlong"
      if (!data["computation"]["compensationDone"])
        key="coord_init_latlong";
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 30,
            attribution: '&copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap contributors</a>',
            opacity: 0.6
          }).addTo(mymap);
  }else{
      mymap = L.map('mapid',{crs: L.CRS.Simple, minZoom: -10});
  }
  mymap.scrollWheelZoom.disable();
  mymap.on('focus', function() { mymap.scrollWheelZoom.enable(); });
  mymap.on('blur', function() { mymap.scrollWheelZoom.disable(); });

  var info = L.control();
  info.onAdd = function (map) {
      this._div = L.DomUtil.create('div', 'map-info');
      this._div.innerHTML = '<p><img src="res/marker_f.png"/>'
        +_('Ref')+'</p><p><img src="res/marker_s.png"/>'
        +_('Station')+'</p><p><img src="res/marker_t.png"/>'
        +_('Cible')+'</p>';
      return this._div;
  };
  info.addTo(mymap);

  var len_factorE=1;
  var len_factorN=1;
  var isSimpleCRS=true;
  if ((data["computation"]["projection"]["is_georef"]) && (all_pts.length>0))
  {
    isSimpleCRS=false;
    len_factorE=360/(Math.PI*2*parseFloat(data.computation.projection.earth_model_radius))/Math.cos(Math.PI/180*all_pts[0][key][1]);
    len_factorN=360/(Math.PI*2*parseFloat(data.computation.projection.earth_model_radius));
  }
  for (var i = 0; i < all_axes.length; i++) {
    var axe = all_axes[i];
    var pos = all_axes[i].origin[key];
    var axe_norm=Math.sqrt(axe.params.a*axe.params.a+axe.params.b*axe.params.b+axe.params.c*axe.params.c);
    var ellips_az = Math.atan2(axe.params.a,axe.params.b)*180/Math.PI;
    var axe_proj_norm = Math.sqrt(axe.params.a*axe.params.a+axe.params.b*axe.params.b);
    //console.log(all_axes[i].origin.name,axe_norm,axe_proj_norm,axe.params.c/axe_norm);
    for (var j = 0; j< axe.targets.length; j++) {
        var target = axe.targets[j];
        var ellips_ctr = [pos[0]+target.params.l*axe.params.a*len_factorE, pos[1]+target.params.l*axe.params.b*len_factorN];
        var ellips_a = target.params.r;
        //var ellips_b = ellips_a*axe_proj_norm/axe_norm;
        var ellips_b = Math.abs(ellips_a*axe.params.c/axe_norm);
        L.ellipse([ellips_ctr[1],ellips_ctr[0]],[ellips_a,ellips_b],
            ellips_az,{color: 'coral',opacity : 0.7,fill:false, simpleCRS:isSimpleCRS}).addTo(mymap);
    }
  }
  
  for (var i = 0; i < all_axes.length; i++) {
    var axe = all_axes[i];
    var pos = all_axes[i].origin[key];
    var axe_norm=Math.sqrt(axe.params.a*axe.params.a+axe.params.b*axe.params.b+axe.params.c*axe.params.c);
    var axe_len_m=2//show +/- 2m
    var posA = [pos[0]+axe_len_m*len_factorE*axe.params.a/axe_norm, pos[1]+axe_len_m*len_factorN*axe.params.b/axe_norm];
    var posB = [pos[0]-axe_len_m*len_factorE*axe.params.a/axe_norm, pos[1]-axe_len_m*len_factorN*axe.params.b/axe_norm];
    var polyline = L.polyline([
        [posA[1], posA[0]],
        [posB[1], posB[0]]
      ],{weight: 8, opacity : 1, color: "olivedrab", dashArray:"12"}).addTo(mymap);
  }
  
  function createObsLine(from, to, obs_color, layerObsLine, layerObsDir) {
    var v = [from[0]-to[0], to[1]-from[1]];
    var norm = Math.sqrt(v[0]*v[0]+v[1]*v[1]);
    if (norm>0) {
      v[0] = v[0] / norm / 5 * len_factorE;
      v[1] = v[1] / norm / 5 * len_factorE;
    }
    layerObsLine.push(L.polyline([
      [from[1], from[0]],
      [to[1], to[0]]
    ],{weight: 1, opacity : 0.5, color: obs_color}));
    layerObsDir.push(L.polyline([
      [(from[1]+to[1])/2+v[1]*2, (from[0]+to[0])/2-v[0]*2],
      [(from[1]+to[1])/2+v[0]+v[1], (from[0]+to[0])/2+v[1]-v[0]]
    ],{weight: 1, opacity : 0.5, color: obs_color}));
    layerObsDir.push(L.polyline([
      [(from[1]+to[1])/2+v[1]*2, (from[0]+to[0])/2-v[0]*2],
      [(from[1]+to[1])/2-v[0]+v[1], (from[0]+to[0])/2-v[1]-v[0]]
    ],{weight: 1, opacity : 0.5, color: obs_color}));
  }

  var layerObsLine = [];
  var layerObsDir = [];
  for (var obs of all_obs) {
    if (obs.active && obs.code>0 && obs.code<110) { //do not draw coord, axes and internal contraints
      var coord_latlong_from = all_pts_name[obs.from][key];
      var coord_latlong_to = all_pts_name[obs.to][key];
      var obs_color = "darkmagenta";
      createObsLine(coord_latlong_from, coord_latlong_to, obs_color, layerObsLine, layerObsDir);
    }
  }
  var layerObs={"Obs":L.layerGroup(layerObsLine), "Dir":L.layerGroup(layerObsDir)};
  L.control.layers(null, layerObs, {collapsed:false}).addTo(mymap);

  kernVectScale = 5*len_factorE;
  kernVectColor = "#FF0000FF";

  function drawKernVect(v, layer) {
    var pt = all_pts[v.n];
    var pos = pt[key];
    var vx = v.x*kernVectScale;
    var vy = v.y*kernVectScale;
    var vz = v.z*kernVectScale;
    var miniSize2 = 0.1*len_factorE*len_factorE;

    if (vx*vx+vy*vy>miniSize2)
    {
      layer.push(L.polyline([
        [pos[1], pos[0]],
        [pos[1]+vy, pos[0]+vx]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vy, pos[0]+vx],
        [pos[1]+vy+(-vx-vy)/8, pos[0]+vx+(+vy-vx)/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vy, pos[0]+vx],
        [pos[1]+vy+(+vx-vy)/8, pos[0]+vx+(-vy-vx)/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
    }
    if (vz*vz>miniSize2)
    {
      layer.push(L.polyline([
        [pos[1], pos[0]],
        [pos[1]+vz, pos[0]]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz*0.4, pos[0]-vz/16],
        [pos[1]+vz*0.6, pos[0]+vz/16]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz*0.4, pos[0]-vz/16],
        [pos[1]+vz*0.4, pos[0]+vz/16]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz*0.6, pos[0]-vz/16],
        [pos[1]+vz*0.6, pos[0]+vz/16]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz, pos[0]],
        [pos[1]+vz-vz/8, pos[0]-vz/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz, pos[0]],
        [pos[1]+vz-vz/8, pos[0]+vz/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
    }
  }
  
  function drawKernCirc(pos, val, layer) {
    if (val>0)
      layer.push(L.marker([pos[1], pos[0]], {icon:markerIconR1}));
    else
      layer.push(L.marker([pos[1], pos[0]], {icon:markerIconR2}));
  }

  function drawKernel(num, kernLayers) {
    var layer = [];
    var kernData = data["computation"]["kernel"][num];
    var allVects = {}; //{x,y} indexed by pt name
    for (param in kernData)
    {
      var val = kernData[param].val;
      var dim = param.substring(param.lastIndexOf("_")+1);
      var numpt = kernData[param].num_pt;
      var pt = all_pts[numpt];
      if (dim[0]=="G")
        drawKernCirc(pt[key], val, layer);
      if (dim[0]=="x")
      {
        if (pt.name in allVects)
          allVects[pt.name]["x"] = val;
        else {
          allVects[pt.name] = {"n":numpt,"x":0.0,"y":0.0,"z":0.0};
          allVects[pt.name]["x"] = val;
        }
      }
      if (dim[0]=="y")
      {
        if (pt.name in allVects)
          allVects[pt.name]["y"] = val;
        else {
          allVects[pt.name] = {"n":numpt,"x":0.0,"y":0.0,"z":0.0};
          allVects[pt.name]["y"] = val;
        }
      }
      if (dim[0]=="z")
      {
        if (pt.name in allVects)
          allVects[pt.name]["z"] = val;
        else {
          allVects[pt.name] = {"n":numpt,"x":0.0,"y":0.0,"z":0.0};
          allVects[pt.name]["z"] = val;
        }
      }
    }
    //console.log("All vects: "+dim+": "+JSON.stringify(allVects));
    for (pt in allVects)
      drawKernVect(allVects[pt], layer);
    var kernLayer = L.layerGroup(layer);
    if (num==0)
      kernLayer.addTo(mymap);
    kernLayers["Indetermination "+num.toString()] = kernLayer;
  }

  if (data["computation"]["kernel"])
  {
    var kernLayers = {};
    for (var num=0;num<data["computation"]["kernel"].length;num++)
      drawKernel(num, kernLayers);
    L.control.layers(kernLayers, null, {collapsed:false}).addTo(mymap);
  }

  for (var i = 0; i < nb_pts; i++)
  {
    var pt = all_pts[i];
    var coord_latlong=all_pts[i][key];
    if ([1,2,3,5,7,9].indexOf(all_pts[i].code)>=0)
    {
        L.marker([coord_latlong[1], coord_latlong[0]], {icon:markerIconF}).bindTooltip(data.all_point_names[i],{permanent: true, direction: 'right', className: 'comp-tooltips'}).addTo(mymap);
        continue;
    }
    var iconFound=false;
    for (const st of pt.stations)
    {
        if (st.type !== "simple")
        {
            L.marker([coord_latlong[1], coord_latlong[0]], {icon:markerIconS}).bindTooltip(data.all_point_names[i],{permanent: true, direction: 'right', className: 'comp-tooltips'}).addTo(mymap);
            iconFound=true;
            continue;
        }
    }
    if (!iconFound)
        L.marker([coord_latlong[1], coord_latlong[0]], {icon:markerIconT}).bindTooltip(data.all_point_names[i],{permanent: true, direction: 'right', className: 'comp-tooltips'}).addTo(mymap);
  }

  L.control.scale({imperial:false}).addTo(mymap);
  for (var i = 0; i < nb_pts; i++) {
    var coord_latlong=all_pts[i][key];
    if (isFinite(coord_latlong[0]) && isFinite(coord_latlong[1]))
      all_latlong.push( [coord_latlong[1],coord_latlong[0]] );
  }
  if (all_latlong.length>0)
  {
    minx=all_latlong[0][0];
    miny=all_latlong[0][1];
    maxx=all_latlong[0][0];
    maxy=all_latlong[0][1];
    for (var pt of all_latlong) {
        if (minx>pt[0]) minx=pt[0];
        if (miny>pt[1]) miny=pt[1];
        if (maxx<pt[0]) maxx=pt[0];
        if (maxy<pt[1]) maxy=pt[1];
    }
    minx-=0.0001;
    miny-=0.0001;
    maxx+=0.0001;
    maxy+=0.0001;
    mymap.fitBounds( [[minx,miny],[maxx,maxy]]);

    L.Control.ResetZoom = L.Control.extend({
        onAdd: function(map) {
            var div = L.DomUtil.create('div');
            div.classList.add("leaflet-control-zoom");
            div.classList.add("leaflet-bar");
            div.classList.add("leaflet-control");
            div.innerHTML='<a class="leaflet-control-zoom-in" title="Reset zoom" onclick="mymap.fitBounds( [[minx,miny],[maxx,maxy]]);">‚õã</a>';
            return div;
        },
        onRemove: function(map) {}
    });
    L.control.resetZoom = function(opts) {
        return new L.Control.ResetZoom(opts);
    }
    L.control.resetZoom({ position: 'topleft' }).addTo(mymap);
  }
}

$(document).ready(function() {
  document.title='... - Comp3D';//update window title ASAP
  $("#title").text("");
  $("#title").addClass("spinner");

  var script_data = document.createElement("script");
  script_data.onload = function () {
      title=data["config"]["name"]; //global variable //update window title ASAP
      if (title==="")
        title=data["config_file"].replace(/^.*[\\\/]/, '');
      document.title=title+_(' - Comp3D');
      setTimeout(() => {
            showComp3Djson(data);
            $("#title").removeClass("spinner");
        }, 0);
  };
  script_data.src = data_file;
  script_data.type = "text/javascript";
  document.head.appendChild(script_data);
});
